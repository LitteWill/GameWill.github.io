<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L Blog</title>
  
  <subtitle>Record growth.</subtitle>
  <link href="https://github.com/LittleWills/GameWill.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/LittleWills/GameWill.github.io.git/"/>
  <updated>2022-03-20T17:22:58.529Z</updated>
  <id>https://github.com/LittleWills/GameWill.github.io.git/</id>
  
  <author>
    <name>Little Will</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Actor模型</title>
    <link href="https://github.com/LittleWills/GameWill.github.io.git/2022/03/06/Actor%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/LittleWills/GameWill.github.io.git/2022/03/06/Actor%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-03-06T14:47:13.000Z</published>
    <updated>2022-03-20T17:22:58.529Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>Gul Agha提出了两个论点:一个Actor对象可以创建其他Actor对象；一个顺序进程无法创建其他顺序进程。<br>这两个论点并非贬低顺序程序的作用。而且也不是说，一个顺序进程无法执行其他顺序进程（数十年的主流开发经验已经证明了这一点）。但是，顺序进程仍旧是静态的，而且只能完成专门化的任务。与此相比，在高动态环境（在这种环境中可以根据需要创建和删除Actor对象，甚至可以在运行程序时，根据领域或操作环境需求更改Actor对象的行为）中，Actor 模型既可以利用顺序编程技巧，也可以利用函数编程技巧。响应式系统不仅拥有并发性和分布性，而且还拥有弹性、动态性、响应性和韧性。</p></blockquote><span id="more"></span><h1 id="Actor模型"><a href="#Actor模型" class="headerlink" title="Actor模型"></a>Actor模型</h1><h1 id="Actor-模型的起源"><a href="#Actor-模型的起源" class="headerlink" title="Actor 模型的起源"></a>Actor 模型的起源</h1><p>Actor 模型是一种用于处理并发计算的数学模型，它将Actor 对象用作并发计算的通用基元。与其他计算模型不同，发明Actor模型的灵感源于物理学理论，如广义相对论和量子力学。<br>可以将Actor 模型视为创建响应式应用程序的手段之一。使用这种具体的响应式软件开发方法，可以细致地处理响应式应用程序的主要方面：响应性、韧性、弹性和消息驱动性。它通过消息传递方式实现这四个方面的功能。<br>Carl Hewitt 博士是Actor 软件开发模型的发明者，他为研究该模型投入了数十年时间。Carl Hewitt 博士发现某些计算问题需要使用并发和分布模式解决，但他在做这项研究时第一台晶体管计算机仅出现了14 年，还不存在多核处理器。在1973年，功能最强大的Intel 处理器仅含有4000 至5000 个晶体管，其主频还没有超过1MHz。Carl Hewitt 博士在研究Actor 模型时，能够使用的功能最强大的处理器。处理器的硬件能力无法将Carl Hewitt 提出的理论付诸实践。因此，当时分布式和并行系统知识的理论模型与现实情况不匹配。<br><img src="image.jpg" alt="image"><br><strong><center>1973 年左右功能最强大的处理器</center></strong></p><h1 id="了解Actor-模型"><a href="#了解Actor-模型" class="headerlink" title="了解Actor 模型"></a>了解Actor 模型</h1><p>Actor 是一种计算实体，它会对收到的消息做出回应，并且可以做下列事情：<br>■ 向其他Actor 对象发送一定数量的消息。<br>■ 创建一定数量的新Actor 对象。<br>■ 设定对下一条消息做出的回应方式。<br>执行这些操作的次序不分先后，而且可以通过并行方式执行它们。<br>在功能齐全的Actor 系统中，所有事物都是Actor 对象。这意味着我们通常使用的基本数据类型（如字符串和整型）都是Actor对象。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTAxMTgzOC8yMDE4MTEvMTAxMTgzOC0yMDE4MTExNTE0NTQwNjYwOS0xNjEyMDM0NjU0LnBuZw"><br>Actor 是由状态（state）、行为（behavior）、邮箱（mailbox）三者组成的：</p><ul><li>状态（state）：状态是指 actor 对象的变量信息，状态由 actor 自身管理，避免并发环境下的锁和内存原子性等问题。</li><li>行为（behavior）：行为指定的是 actor 中计算逻辑，通过 actor 接收到的消息来改变 actor 的状态。</li><li>邮箱（mailbox）：邮箱是 actor 之间的通信桥梁，邮箱内部通过 FIFO 消息队列来存储发送发消息，而接收方则从邮箱中获取消息。</li></ul><p>Actor 模型描述了一组为避免并发编程的公理：</p><ul><li>所有的 Actor 状态是本地的，外部是无法访问的。</li><li>Actor 必须通过消息传递进行通信</li><li>一个 Actor 可以响应消息、退出新 Actor、改变内部状态、将消息发送到一个或多个 Actor。</li><li>Actor 可能会堵塞自己但 Actor 不应该堵塞自己运行的线程</li></ul><hr><h2 id="并发线程通信方式"><a href="#并发线程通信方式" class="headerlink" title="并发线程通信方式"></a>并发线程通信方式</h2><p>一般而言，有两种策略用来在并发线程中进行通信：<strong>共享数据</strong>和<strong>消息传递</strong> 。</p><h3 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a><strong>共享数据</strong></h3><p>使用<strong>共享数据</strong> 的并发编程，一般会使用各种锁去处理相关的线程安全问题；但同时也要处理各种锁所带来的问题。</p><p><strong>死锁</strong> ：锁的设计不当，会出现两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去的现象。</p><p><strong>效率低：</strong> 在高度竞争的阶段，很有可能出现很长的线程队列，他们都在等待递减计数器。但使用队列的方式的问题在于可能造成众多阻塞线程，也就是每个线程都在等待轮到它们去执行一个序列化的操作。</p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>实现消息传递有两种常见类型：<strong>基于channel的消息传递</strong>和<strong>基于Actor的消息传递</strong> 。</p><p>和共享数据方式相比，消息传递机制最大的优势在于不会产生数据竞争状态。共享内存是倾向于强一致性弱隔离性的，例如悲观锁同步的方式就是使用强一致性的方式控制并发，而 Actor 模型天然是是强隔离性且弱一致性的，所以 Actor 模型在并发中有良好的性能，而且易于控制和管理。</p><h1 id="Actor消息传递避免数据竞争原理"><a href="#Actor消息传递避免数据竞争原理" class="headerlink" title="Actor消息传递避免数据竞争原理"></a>Actor消息传递避免数据竞争原理</h1><p>想象我们在抢火车票，有两个线程并发地调整计数器，该计数器目前的值是 5。线程一想要将计数器的值递减 3，而线程二想要将计数器的值递减 4。它们都会检查当前计数器的值，并且会断定计数器的值大于要递减的数量。然后，它们都会继续运行并递减计数器的值。最后的结果就是 5 - 4 - 3 = -2。这样的结果会造成货品的过度分配，违反了特定的业务规则。</p><p>现在，我们将基于线程的实现替换为 Actor。 当然，Actor 也要在线程中运行，但是 Actor 只有在有事情可做的时候才会使用线程。在我们的计数器场景中，请求者代表了 Customer Actor。门票的数量现在由 Actor 来维护，它持有当前计数器的状态。Customer Actor 和 Tickets Actor 在空闲时（也就是没有消息要处理）都不会持有线程。</p><p>要初始购买操作，Customer Actor 需要发送一条 buy 消息给一个 Tickets Actor。在这样的 buy 消息中包含了要购买的数量。当 Tickets Actor 接收到 buy 消息时，它会校验购买数量不超过当前剩余的数量。如果购买请求是合法的，数量就会递减，Tickets Actor 会发送一条信息给 Customer Actor，表明订单被成功接受。如果购买数量超出了剩余数量的话，Tickets Actor 将会发送给 Customer Actor 一条消息，表明订单被拒绝了。Actor 模型本身确保处理是按照同步的方式进行的。</p><p>我们分三步展示 actor 之间的交互：</p><ol><li>Customer Actor 发送 buy 消息</li><li>Tickets Actor 处理消息</li><li>Tickets Actor 拒绝购买请求</li></ol><p><strong>1.Customer Actor 发送 buy 消息：</strong>  Customer Actor，它们各自发送 buy 消息给 Tickets Actor。这些 buy 消息会在 Tickets Actor 的收件箱（mailbox）中排队。发送一条消息并未将 “执行线程” 从发送者转移到目标。一个 actor 可以发送一条消息并继续无阻塞地运行。因此，在同样的时间内，它可以完成更多任务。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvNzIvNjUvNzIyODA0ZmU3MzU4N2EwNDYzMjkxMWY1NGVjYTk1NjUuanBn"></p><p><strong><center>Customer Actor 发送 buy 消息</center></strong> </p><p><strong>2.Tickets Actor 处理消息：</strong> 如下展示的是请求购买五张门票的第一条消息。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvMzUvMmYvMzUyOWUwYzAyN2QxZWU3YWUyZDc2ZGI1OTRjYzI1MmYuanBn"></p><p><strong><center>Tickets Actor 处理消息</center></strong> </p><p>当一个 Tickets  Actor 收到一条消息时，Tickets  Actor 将这条消息添加到队列尾部，如果 Tickets  Actor 没有被调度执行，它将被标记为 ready。一个调度器获取这个 Tickets  Actor 并开始执行它：Tickets  Actor 在队列头部取出一条消息。</p><p>随后，Tickets Actor 检查购买数量没有超出剩余门票的数量。在当前的情况下，门票数量是 15，因此购买请求能够接受，剩余门票数量会递减，Tickets Actor 还会发送一条消息给发出请求的 Customer Actor，表明门票购买成功。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvMWMvNzcvMWMyZGZiYWVjZTg0ODMxMTdjYmZjNzhmYzViZGU0NzcuanBn"></p><p><strong><center>Tickets Actor 处理消息队列</center></strong></p><p>Tickets Actor 会处理其收件箱中的每条消息。需要注意，这里没有复杂的线程或锁。这是一个<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a>的处理过程，但是 Actor 系统会管理线程的使用和分配。</p><p>在这里 Actor 区别于多线程并发模型的是，多线程并发模型改变了 actor 并对内部状态，而 actor 独立处理收到的消息，并且它们一个一个地响应连续到来的消息。虽然每个 actor 连续地处理发给它的消息，不同的 actors 之间并发地工作，所以一个 actor 系统可以同时处理多条消息。因为每个 actor 中同时最多处理一个消息，所以 Actor 模型无需使用锁。</p><p><strong>3.Tickets Actor 拒绝购买请求：</strong>  当请求的数量超过剩余值时，Tickets Actor 会如何进行处理。这里所展现的是当我们请求两张门票，但是仅剩一张门票时的情况。Tickets Actor 会拒绝这个购买请求并向发起请求的 Customer Actor 发送一条 “sold out”的消息。</p><p><img src="image_2.png" alt="image_2"></p><p><strong><center>Tickets Actor 拒绝购买请求</center></strong></p><p>当然，在线程方面有一定经验的开发人员会知道，可划分为两个阶段的行为检查和门票数量递减能够通过同步的操作序列来完成。以在 Java 中为例，我们可以使用同步的方法或语句来实现。但是，基于 Actor 的实现不仅在每个 Actor 中提供了自然的操作同步，而且还能避免大量的线程积压，防止这些线程等待轮到它们执行同步代码区域。在门票样例中，每个 Customer Actor 会等待响应，此时不会持有线程。这样所形成的结果就是基于 Actor 的方案更容易实现，并且会明显降低系统资源的占用。</p><h1 id="Actor-系统和Actor-对象基本特点"><a href="#Actor-系统和Actor-对象基本特点" class="headerlink" title="Actor 系统和Actor 对象基本特点"></a>Actor 系统和Actor 对象基本特点</h1><p><strong>■ 直接通过异步消息传递方式进行通信：</strong> 如果Actor 对象A1 要向Actor 对象A2 发送消息M1，那么Actor 对象A1 就必须知道Actor 对象A2 的地址。如果Actor 对象A1 知道Actor 对象A2的地址，那么它就能够直接向Actor 对象A2 发送消息M1，但Actor 对象A2 会使用独立线程接收和处理消息M1。换言之，消息M1 是通过异步方式被发送给Actor 对象A2 的。实际上，在发送者Actor 对象和接收者Actor 对象之间还存在一个间接处理层——邮箱（消息缓存单元）。即便如此，我们还是将这种消息传输方式称为直接传输方式，因为编程模型提供了一种宝贵的抽象，该抽象使消息就像直接从一个Actor 对象传输到另一个Actor 对象一样。</p><p><strong>■ 状态机：</strong> Actor 模型支持有限状态机。当Actor 对象转换为某个预设状态时，就能够改变对未来接收到的信息的处理模式。通过变为另一种消息处理器，Actor 对象就成了一种有限状态机。</p><p><strong>■ 无共享：</strong> 一个Actor 对象不会与其他Actor 对象或相关组件共享可变状态</p><p><strong>■ 无锁的并发处理方式：</strong> 因为Actor 对象不会共享它们的可变状态，而且它们在同一时刻仅会接收一条消息，所以在对消息做出回应前，Actor 对象永远都不需要尝试锁定它们的状态。因为无须使用锁策略，所以它们能够将多核CPU 从锁定问题中解放出来，集中精力提高吞吐量，并且使所有处理响应式组件的线程不被阻塞。</p><p><strong>■ 并行性：</strong> 并发处理方式和并行处理方式是不同的概念。并发处理方式是指多个计算操作同时出现。并行处理方式是指以并发处理方式完成单个目标。并行性是通过将单个的复杂处理过程拆分成较小的任务并以并发处理方式执行它们实现的。当等级较高的Actor 对象能够将多个任务分派给多个下级Actor 对象，或者任务中含有复杂的处理层级时，就适合通过Actor 模型使用并行处理方式。</p><p><strong>■ Actor 对象的系统性：</strong> 单个Actor 对象不具备并行性。Actor 对象的量级非常轻，因此在单个系统中创建许多Actor 对象是受推荐的处理方式。任何问题都可以通过添加Actor 对象来解决。</p><p><strong>■ 位置透明性：</strong> 使用抽象引用代表Actor 对象的地址。如果Actor 对象A1获得了Actor 对象A2 的引用，Actor 对象A1 就能够向Actor 对象A2 发送消息。提供支持的Actor 系统会负责处理传送消息的操作，不论Actor对象A2 是位于本地Actor 系统还是位于远程Actor 系统中。</p><p><strong>■ 监督：</strong> 在Actor 对象之间建立依赖关系，父Actor 对象监督子（下级）Actor 对象。当监督者Actor 对象向下级Actor 对象分派任务时，就必须对这些下级Actor 对象出现的失效情况做出回应。合法的回应包括继续运行、重启和停止下级Actor 对象。监督者还可以通过使本身失效从而使失效情况升级，这会将失效控制权上交给监督者的父对象（监督者的监督者）。监督机制适于在并行处理方式中使用，在该方式中监督者会将多个任务分派给多个下级对象，从而形成任务处理层级。</p><p>作为一种计算实体，Actor 对象与原子类似。在有可用线程的情况下，每个Actor 对象都会在收到消息时处理这条消息并且在同一时刻仅能处理一条消息，Actor 对象的性能完全由其本身的吞吐量决定，因此可以说，Actor 对象是按照自己的节奏在工作。然而，因为Actor 对象不会与其他Actor 对象共享可变状态，所以当通过计算或数据处理操作处理收到的消息时，Actor 对象也不必锁定系统资源。</p><p><img src="image_1.png" alt="image_1"></p><p><strong><center> 在有可用线程的情况下，每个Actor 对象都会在收到消息时处理这条消息 </center></strong></p><p><strong><center>并且在同一时刻仅能处理一条消息</center></strong></p><p>在无锁情况下，理论上，Actor 对象的吞吐速度会非常快。即使在某些特殊情况中，如果计算和处理操作比较小、集中和耗时较短，那么通常消息就会以极为迅速的方式被发送、接收和处理。这就使你有可能避免使用阻塞机制和导致阻塞问题的机制（串行设备）。因此，Actor 系统就能够拥有高性能、高吞吐量和低操作延迟。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《响应式架构：消息模式Actor实现与Scala、Akka应用集成》 沃恩.弗农</p><p><a href="https://www.infoq.cn/article/Reactive-Systems-Akka-Actors-DomainDrivenDesign">使用Akka的Actor模型和领域驱动设计构建反应式系统-InfoQ</a></p><p><a href="https://www.jianshu.com/p/d803e2a7de8e">Actor模型 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Gul Agha提出了两个论点:一个Actor对象可以创建其他Actor对象；一个顺序进程无法创建其他顺序进程。&lt;br&gt;这两个论点并非贬低顺序程序的作用。而且也不是说，一个顺序进程无法执行其他顺序进程（数十年的主流开发经验已经证明了这一点）。但是，顺序进程仍旧是静态的，而且只能完成专门化的任务。与此相比，在高动态环境（在这种环境中可以根据需要创建和删除Actor对象，甚至可以在运行程序时，根据领域或操作环境需求更改Actor对象的行为）中，Actor 模型既可以利用顺序编程技巧，也可以利用函数编程技巧。响应式系统不仅拥有并发性和分布性，而且还拥有弹性、动态性、响应性和韧性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Actor模型" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/Actor%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="Actor模型" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/Actor%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="线程安全" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>应用层</title>
    <link href="https://github.com/LittleWills/GameWill.github.io.git/2022/01/16/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>https://github.com/LittleWills/GameWill.github.io.git/2022/01/16/%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2022-01-16T12:33:10.000Z</published>
    <updated>2022-04-30T16:21:54.724Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。目前流行的主要有以下两种：客户/服务器方（Client/Server）式和对等(Peer-to-Peer)方式。</p></blockquote><span id="more"></span><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。</p><h1 id="C-S方式和P2P方式"><a href="#C-S方式和P2P方式" class="headerlink" title="C/S方式和P2P方式"></a>C/S方式和P2P方式</h1><p>网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。</p><p>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和他们之间的关系。</p><p>目前流行的主要有以下两种：客户/服务器方（Client/Server）式和对等(Peer-to-Peer)方式。</p><h2 id="C-S方式"><a href="#C-S方式" class="headerlink" title="C/S方式"></a>C/S方式</h2><p><img src="image/image.png" alt="image"></p><ul><li>客户/服务器方式<br>  客户和服务器是指通信中所涉及的两个应用进程；<br>  客户/服务器方式所描述的是进程之间服务和被服务的关系；<br>  客户是服务请求方，服务器是服务提供方；<br>  服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（例如HTTP服务器的默认端口号为80），而运行服务器的主机也具有固定的IP地址。</li><li>C/S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C/S方式。包括万维网WWW、电子邮件、文件传输FTP等。</li><li>基于C/S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上。<br>  由于一台服务器计算机要为多个客户机提供服务，在C/S应用中，常会出现服务计算机跟不上众多客户机请求的情况。为此，在C/S应用中，常用计算机群集（或服务器场）构建一个强大的虚拟服务器。</li></ul><h2 id="P2P方式"><a href="#P2P方式" class="headerlink" title="P2P方式"></a>P2P方式</h2><p><img src="image/image_1.png" alt="image"></p><ul><li>对等方式<br>  在P2P方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等放好。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</li><li>目前，在因特网上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等。</li><li>基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，他们通常位于住宅、校园和办公室中。</li><li>P2P方式的最突出特性之一就是它的可扩展性。因为系统每增加一个对等方，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低。</li></ul><h1 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h1><h2 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h2><p><img src="image/image_2.png" alt="image"></p><p>如果我们给网络中添加一台DHCP服务器，在该服务器设置好可为网络中其他各主机配置的网络配置信息。网络中各主机开机后自动启动DHCP程序向DHCP服务器请求自己的网络配置信息。这样，网络中的各主机就都可以从DHCP服务器自动获取网络配置信息而不用手工参与。</p><h2 id="DHCP工作过程"><a href="#DHCP工作过程" class="headerlink" title="DHCP工作过程"></a>DHCP工作过程</h2><p><img src="image/image_3.png"></p><h3 id="寻找DHCP服务器"><a href="#寻找DHCP服务器" class="headerlink" title="寻找DHCP服务器"></a>寻找DHCP服务器</h3><p><img src="image/image_4.png" alt="image"></p><p>当启用主机的DHCP后，DHCP客户将广播发送DHCP发现报文，封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址，因此使用该地址来代替。目的IP地址为广播地址255.255.255.255，之所以进行广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器，它们的IP地址各是什么。由于是广播的IP数据报，因此网络中的所有设备都会收到该IP数据报，解封出封装有DHCP发现报文的UDP用户数据报。对于DHCP客户，其应用层没有监听该UDP用户数据报目的端口67的进程，也就是DHCP服务器的进程，因此无法交付DHCP发现报文，只能丢弃；而对于DHCP服务器，其应用层始终运行着DHCP服务器进程，因此会接受该DHCP发现报文并做出响应。</p><blockquote><p>DHCP报文逐层封装的过程：封装有DHCP报文的UDP用户数据报，在网络层会被封装成IP数据报，然后再根据所使用的网络接口，封装成相应的数据链路层的帧进行发送，例如封装成以太网帧。</p></blockquote><h3 id="提供IP地址租用"><a href="#提供IP地址租用" class="headerlink" title="提供IP地址租用"></a>提供IP地址租用</h3><p><img src="image/image_5.png" alt="image"></p><p>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库，看是否有针对该MAC地址的配置信息，如果有，则使用这些配置信息来构建并发送DHCP提供报文；如果没有，则采用默认配置信息来构建并发送DHCP提供报文，封装该报文的IP数据报的源IP地址为DHCP服务器的IP地址，目的IP地址仍为广播地址。仍然使用广播地址的原因是，主机目前还没有配置IP地址，为了使主机可以收到，只能发送广播。对于DHCP服务器，其应用层没有监听该UDP用户数据报目的端口68的进程，也就是DHCP客户进程，因此无法交付DHCP提供报文，只能丢弃。对于DHCP用户其应用层运行着DHCP客户进程，因此会接受该DHCP提供报文并作出相应的处理。DHCP客户会根据DHCP提供报文中的事务ID，来判断该报文是否是自己请求的报文，否则丢弃该报文。</p><blockquote><p>DHCP发现报文其内部封装有事务ID和DHCP客户端的MAC地址。DHCP提供报文中封装有事务ID、配置信息（IP地址、子网掩码、地址租期、默认网关、DNS服务器）DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址时，会使用ARP确保所选IP地址未被网络中其他主机占用。</p></blockquote><h3 id="接受IP地址租约"><a href="#接受IP地址租约" class="headerlink" title="接受IP地址租约"></a>接受IP地址租约</h3><p><img src="image/image_6.png" alt="image"></p><p>DHCP客户收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般来说，选择先到的那个，并向所选择的DHCP服务器发送DHCP请求报文。封装该报文的IP地址仍为0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器，它首先需要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址，目的IP地址仍为广播地址；目的是不用向网络中的每一个DHCP服务器单播发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器。</p><blockquote><p>DHCP请求报文中封装有事务ID、DHCP客户端的MAC地址、接收的租约中的IP地址、提供此租约的DHCP服务器端的IP地址</p></blockquote><h3 id="确认IP地址租约"><a href="#确认IP地址租约" class="headerlink" title="确认IP地址租约"></a>确认IP地址租约</h3><p><img src="image/image_7.png" alt="image"></p><p>假设DHCP客户选择DHCP服务器1作为自己的DHCP服务器，并且DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户发送DHCP确认报文，封装该报文的IP数据报的源IP地址为DHCP服务器1的IP地址，目的IP地址仍为广播地址；DHCP客户收到该确认报文后，就可以使用所租用到的IP地址了。</p><blockquote><p>主机使用ARP检测所分配到的IP地址是否已被网络中其他主机占用：若被占用：给DHCP服务器发送“DHCP DECLINE”谢绝报文撤销IP地址租约，并重新发送“DHCP DISCOVER”报文；若未被占用：可以使用租约中的IP地址与网络中其他主机通信了。</p></blockquote><h3 id="IP地址续约"><a href="#IP地址续约" class="headerlink" title="IP地址续约"></a>IP地址续约</h3><p><img src="image/image_8.png" alt="image"></p><p>当租用期过了一半，DHCP客户会向DHCP服务器发送DHCP请求报文，来请求更新租用期。封装该报文的IP数据报的源IP地址为DHCP客户之前租用到的IP地址，目的IP地址为DHCP服务器1的地址。DHCP服务器若同意，则发回DHCP确认报文，DHCP客户就得到了新的租用期；DHCP服务器若不同意，则发回DHCP否认报文。这时，DHCP客户必须立即停止使用之前租用的IP地址，并重新发送DHCP发现报文来重新申请IP地址；DHCP服务器若未作出响应，则在租用期过了87.5%时，DHCP客户必须重新发送DHCP请求报文，然后继续等待DHCP服务器可能做出的反应（若DHCP未作出反应，则当租用期到期后，DHCP客户必须立即停止使用之前租用的IP地址，并重新发送DHCP发现报文来重新申请IP地址。）</p><h3 id="随时解除IP地址租用"><a href="#随时解除IP地址租用" class="headerlink" title="随时解除IP地址租用"></a>随时解除IP地址租用</h3><p><img src="image/image_9.png" alt="image"></p><p>DHCP客户可以随时提前终止DHCP服务器所提供的租用期，这时只需向DHCP服务器发送DHCP释放报文段即可。</p><h2 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h2><p>我们并不愿意在每一个网络上都设置一个DHCP服务器，因为这样会使DHCP服务器的数量太多。</p><p><img src="image/image_10.png" alt="image"></p><p>该网络中的各主机是不可以通过DHCP来自动获取到网络配置信息，因为该网络中的主机广播发送DHCP发现报文，但该广播报文不会被路由器转发，而是丢弃。解决方法是给该路由器配置DHCP服务器的IP地址并使之成为DHCP中继代理。这样该网络中的各主机就可以自动获取到IP地址等网络配置信息。当该路由器收到广播的DHCP发现报文后，会将其单播转发给DHCP服务器。</p><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><h2 id="域名系统DNS概念"><a href="#域名系统DNS概念" class="headerlink" title="域名系统DNS概念"></a>域名系统DNS概念</h2><p>因特网采用层次树状结构的域名结构。域名的结构由若干个分量组成，各分量之间用“点”隔开，分别代表不同级别的域名：</p><p><img src="image/image_11.png" alt="image"></p><ul><li>每一级的的域名都有英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左，而级别最高的顶级域名写在最右。</li><li>完整的域名不超过255个字符。</li></ul><p>域名系统既不规定一个域名需要包含多少下级域名，也不规定每一级的域名代表什么意思。各级域名由上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理。顶级域名TLD分为以下三类：</p><ul><li>国家顶级域名nTLD 采用ISO 3166的规定。如cn表示中国，us表示美国，uk表示英国等等。</li><li>通用顶级域名gTLD 常见的7个通用顶级域名：com（公司企业）、net（网络服务机构）、org（非营利性组织）、int（国际组织）、edu（美国教育结构）、gov（美国政府部门）、mil（美国军事部门）。</li><li>反向域arpa 用于反向域名解析，即IP地址反向解析为域名。</li></ul><p>在国家顶级域名下注册的二级域名均由该国家自行确定。例如：顶级域名为jp的日本，将其教育和企业机构的二级域名定位ac和co，而不用edu和com。我国将二级域名划分为两类：</p><ul><li>类别域名：ac（科研机构）、com（工、商、金融等企业）、edu（教育机构）、gov（政府部门）、net（提供网络服务的机构）、mil（军事机构）和org（非营利性组织）。</li><li>行政区域名：共34个，适用于我国的各省、自治区、直辖市。例如：bj北京市、sh上海市、js江苏省等等。</li></ul><p><img src="image/image_12.png"></p><blockquote><p>这种按等级管理的命名方法便于维护名字得到唯一性，并且也容易设计出一种高效的域名查询机制。域名只是个逻辑概念，并不代表计算机所在的物理地点。</p></blockquote><p>域名和IP地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。域名服务器可以划分为以下四种不同的类型：</p><ul><li>根域名服务器：最高层次的域名服务器。每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址。因特网上共有13个不同IP地址的根域名服务器。尽管这13个根域名服务器中的每一个都视为单个服务器，但实际上是由许多分布在世界各地的计算机构成的服务器群集。当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的一个根域名服务器。这就加快了DNS的查询过程，同时也更合理地利用了因特网的资源。根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名服务器的IP地址。</li><li>顶级域名服务器：这些域名服务器负责管理在该顶级域名服务器注册所有二级域名。当收到DNS查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的IP地址）。</li><li>权限域名服务器：负责管理某个区的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址。</li><li>本地域名服务器：本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出DNS请求报文时，这个报文就首先被送往该主机的本地域名服务器。本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。</li></ul><h2 id="域名系统DNS的作用"><a href="#域名系统DNS的作用" class="headerlink" title="域名系统DNS的作用"></a>域名系统DNS的作用</h2><p><img src="image/image_13.png" alt="image"></p><p>当我们在浏览器地址栏输入某个Web服务器域名时，用户主机会首先在自己的DNS高速缓存中查找该域名所对应的IP地址。</p><p><img src="image/image_14.png" alt="image"></p><p>如果没有找到，则会向网络中的某台DNS服务器发出DNS查询。DNS服务器中有域名和IP地址映射关系的数据库，当DNS服务器收到DNS查询报文后，在其数据库中进行查寻，之后，将查寻结果发送给用户主机，用户主机中的浏览器就可以通过Web服务器的IP地址对其进行访问了。</p><blockquote><p>DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高。由于DNS是分布式系统，即使单个计算机出了故障，也不会妨碍整个系统的正常运行。</p></blockquote><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><p><img src="image/image_15.png" alt="image"></p><p>主机想知道某网址的IP地址，首先向其本地域名服务器进行递归查询。本地域名服务器收到递归查询委托后，也采用递归查询的方式向某个根域名服务器查询。根域名服务器收到递归查询的委托后，也采用递归查询的方式向某个顶级域名服务器查询。顶级域名服务器收到递归查询的委托后，也采用递归查询的方式向某个权限域名服务器查询。当查询到域名所对应的IP地址后，查询结果会在之前受委托的各域名服务器之间传递，最终传回给用户主机。</p><h3 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h3><p><img src="image/image_16.png" alt="image"></p><p>主机首先向其本地域名服务器进行递归查询，本地域名服务器采用迭代查询，它先向某个根域名服务器查询。根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器的IP地址。本地域名服务器向顶级域名服务器进行迭代查询，顶级域名服务器告诉本地域名服务器下一次应查询的权限域名服务器的IP地址。本地域名服务器向权限域名服务器进行迭代查询。权限域名服务器告诉本地域名服务器所查询的域名的IP地址。本地域名服务器最后把查询结果告诉主机。</p><blockquote><p>由于递归查询对于被查询的域名服务器负担太大，所以通常从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询。</p></blockquote><h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><ul><li>为了提高DNS的查询效率，并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量，在域名服务器中广泛使用了高速缓存。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</li><li>由于域名到IP地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并删除超过合理时间的项，如每个项目只存放两天。</li><li>不但在本地域名服务器中需要高速缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和IP地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性。</li></ul><p><img src="image/image_17.png" alt="image"></p><p><img src="image/image_18.png" alt="image"></p><h1 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASCII码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令），FTP屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p><p><img src="image/image_19.png" alt="image"></p><p>FTP采用客户/服务器方式，因特网上的FTP客户计算机可将各种类型的文件上传到FTP服务器计算机。FTP客户计算机也可以从FTP服务器计算机下载文件。根据应用需求的不同，FTP服务器可能需要一台高性能、高可靠性的服务器计算机，也可能只需要一台普通的个人计算机即可。</p><p>FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。FTP的另一个常见用途是让网站设计者将构成网站内容的大量文件批量上传到他们的Web服务器。</p><h2 id="基本工作原理"><a href="#基本工作原理" class="headerlink" title="基本工作原理"></a>基本工作原理</h2><p><img src="image/image_20.png" alt="image"></p><p>FTP客户随机选择一个临时端口号，FTP服务器使用熟知端口号21与其建立TCP连接，用于FTP客户与服务器之间传送FTP的相关控制命令，即命令通道。有数据要传输时，FTP客户通过命令通道告知FTP服务器来与自己的另一个临时端口号建立TCP连接，建立数据通道。FTP客户再随机选择另一个端口号，FTP服务器使用熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件，即数据通道。由于在建立数据通道时，FTP服务器主动连接FTP客户，因此称为主动模式。</p><blockquote><p>控制连接在整个会话期间一直保持打开状态，用于传送FTP相关控制命令。数据连接用于文件传输，在每次文件传输时才建立，传输结束就关闭。</p></blockquote><p><img src="image/image_21.png" alt="image"></p><p>被动模式的不用之处在于当有数据要传输时，FTP客户通过命令通道告知FTP服务器开启某个临时端口被动等待TCP连接，建立数据通道。</p><p><img src="image/image_22.png" alt="image"></p><p><img src="image/image_23.png" alt="image"></p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>电子邮件系统采用客户/服务器方式，其由三个主要组成构建：用户代理、邮件服务器以及电子邮件所需的协议。用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件。邮件服务器是电子邮件系统的基础设施。因特网上所有的ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱。协议包括邮件发送协议（如SMTP）和邮件读取协议（如POP3，IMAP）。</p><p><img src="image/image_24.png" alt="image"></p><p><img src="image/image_25.png" alt="image"></p><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p>简易邮件传送协议SMTP的基本工作原理</p><p><img src="image/image_26.png" alt="image"></p><p>电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义。RFC文档已在2008年更新为RFC5322。一个电子邮件有信封和内容两部分。而内容又由首部和主体两部分构成。</p><p><img src="image/image_27.png" alt="image"></p><p>SMTP协议只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。SMTP不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字（例如中文、俄文、重音符号法文或德文）也无法用SMTP传送。</p><p>为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展MIME（也用于后来同样面向ASCII字符的HTTP）。</p><ul><li>增加了5个新的邮件首部字段，提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ul><h2 id="POP和IMAP"><a href="#POP和IMAP" class="headerlink" title="POP和IMAP"></a>POP和IMAP</h2><p>邮局协议POP，POP3是其第三个版本，是因特网正式标准。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件。（例如创建文件夹，对邮件进行分类管理等）。</p><p>因特网邮件访问协议IMAP，IMAP4是其第四个版本，目前还只是因特网建议标准。功能比POP3强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此IMAP是一个联机协议。</p><p>POP3和IMAP4都采用基于TCP连接的客户/服务器方式。POP3使用熟知端口110，IMAP4使用熟知端口143.</p><h2 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h2><p>通过浏览器登录（提供用户名和口令）邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与IMAP类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通用的万维网浏览器。邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理。</p><p><img src="image/image_28.png" alt="image"></p><p><img src="image/image_29.png" alt="image"></p><p><img src="image/image_30.png" alt="image"></p><p><img src="image/image_31.png" alt="image"></p><h1 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h1><p>万维网并非某种特殊的计算机网络，它是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用，利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网。为了方便访问在世界范围的文档，万维网使用统一资源定位符URL来指明因特网上任何种类“资源”的位置。URL的一般形式由以下四个部分组成：</p><p><img src="image/image_32.png" alt="image"></p><h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2><p>HTTP定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器。</p><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h4><p>HTTP/1.0采用非持续连接方式。在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP连接，当收到响应后就立即关闭连接。</p><p><img src="image/image_33.png" alt="image"></p><p>每请求一个文档就要有两倍RTT的开销。若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费2RTT的时间。为了减小时延，浏览器通常会同时建立多个并行的TCP连接请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。</p><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><p>HTTP/1.1采用持续连接方式。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象而是只要这些文档都在同一个服务器上就行。</p><p>为了进一步提高效率，HTTP/1.1的持续连接还可以使用流水线方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少，提高了下载文档的效率。</p><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p>HTTP是面向文本的，其报文中的每一个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。</p><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p><img src="image/image_34.png" alt="image"></p><p><img src="image/image_35.png" alt="image"></p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p><img src="image/image_36.png" alt="image"></p><p><img src="image/image_37.png" alt="image"></p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>Cookie在服务器上用于记录用户信息，早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种无状态的协议，这样可以简化服务器的设计。现在用户可以通过万维网实现复杂的应用，如网上购物、电子商务等，这些应用往往需要万维网服务器识别用户。Cookie提供了一种机制使得万维网服务器能够记住用户，而无需用户主动提供用户标识信息，即Cookie是一种对无状态的HTTP进行状态化的技术。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="image/image_38.png" alt="image"></p><p>用户主机中的浏览器进程与万维网中的服务器进程建立TCP连接，当用户浏览器进程初次向服务器进程发送HTTP请求报文时，服务器进程就会为其产生一个唯一的Cookie识别码，并以此为索引在服务器的后端数据库中创建一个项目，用来记录该用户访问该网站的各种信息。然后给浏览器进程发回HTTP响应报文，在响应报文中，包含有一个首部字段Set-Cookie的首部行，该字段的取值是Cookie识别码。当浏览器进程收到该响应报文后，就在一个特定的Cookie文件中添加一行，记录该服务器的域名和Cookie的识别码。</p><p><img src="image/image_39.png" alt="image"></p><p>当用户再次使用该浏览器访问这个网站时，每发送一个HTTP请求报文，浏览器都会从Cookie文件中取出该网站的Cookie识别码，并放到HTTP请求报文的Cookie首部行中。服务器根据Cookie识别码就可以识别出该用户，并返回该用户个性化网页。</p><h2 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h2><p><img src="image/image_40.png" alt="image"></p><p>在万维网中还可以使用缓存机制以提高万维网的效率，万维网缓存又称为Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称为代理服务器。Web缓存把最近的一些请求和响应暂存于本地磁盘中。当新请求到达时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按URL的地址再去因特网访问该资源，这样可以大大减少了链路上的通信量，因为减少了访问因特网的时延。</p><p><img src="image/image_41.png" alt="image"></p><p>原始服务器通常会为每个响应的对象，设定一个修改时间字段，和一个有效日期字段。当校园网中的某个主机要请求原始服务器中的该文档时，它首先向校园网中的代理服务器发送请求，若代理服务器中的该文档未过期，则代理服务器将其封装在响应报文中发回给主机。若代理服务器中的该文档已过期，则代理服务器会向因特网上的原始服务器发送请求，在请求报文中包含有一个首部字段为If-modified-since的首部行，取值为该文档的修改日期，原始服务器根据文档的修改日期，就可判断出代理服务器中存储的该文档是否与自己存储的该文档一致。如果一致，则给代理服务器发送不包含实体主体的响应，代理服务器重新更新该文档的有效日期，然后将该文档封装在响应报文中发回给主机；如果不一致，则给代理服务器发送封装有该文档的响应报文。</p><p><img src="image/image_42.png" alt="image"></p><p><img src="image/image_43.png" alt="image"></p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.icourse163.org/course/HNKJ-1461816178">计算机网络_湖南科技大学_中国大学MOOC(慕课) (icourse163.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。网络应用程序运行在处于网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务。目前流行的主要有以下两种：客户/服务器方（Client/Server）式和对等(Peer-to-Peer)方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="应用层" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="应用层" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>运输层</title>
    <link href="https://github.com/LittleWills/GameWill.github.io.git/2022/01/02/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>https://github.com/LittleWills/GameWill.github.io.git/2022/01/02/%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2022-01-02T13:35:10.000Z</published>
    <updated>2022-03-20T17:21:09.897Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。</p></blockquote><span id="more"></span><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。</p><p><img src="image/image.png" alt="image"></p><p>运输层向高层用户屏蔽下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在另个运输层实体之间有一条端到端的逻辑通信信道。根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。</p><p><img src="image/image_1.png" alt="image_1"></p><h1 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h1><p><img src="image/image_2.png" alt="image_2"></p><p>发送方的某些应用进程所发送的不同应用报文，在运输层使用UDP协议进行封装，称为UDP复用；而另一些应用进程所发送的不同应用报文，在运输层使用使用TCP协议进行封装，这称为TCP复用；运输层使用端口号来区分不同的应用进程；不管是使用运输层的UDP封装成的UDP用户数据报，还是使用TCP协议封装成的TCP报文段，在网络层都需要使用IP协议封装成IP数据报，称为IP复用。</p><p>IP数据报首部中协议字段的值，用来表明IP数据报的数据载荷部分，封装的是何种协议数据单元。取值为6表示封装的是TCP报文段；取值为17表示封装的是UDP用户数据报。</p><p>接收方的网络层收到IP数据报后进行IP分用。若IP数据报首部中协议字段的值为17，则把IP数据报的数据载荷部分所封装的UDP用户数据报上交运输层UDP；若协议字段值为6，则把IP数据报的数据载荷部分所封装的TCP报文段上交运输层的TCP。运输层对UDP用户数据报进行UDP分用，对TCP报文段进行TCP分用。也就是根据端口号，将它们交付给上层相应的应用进程。</p><h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>运行在计算机上的进程使用进程标识符PID来标志。因特网上的计算机并不是使用统一的操作系统，不同的操作系统（Windows,Linux,Mac OS）又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标识。</p><p>TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程；端口号使用16比特标识，取值范围0-65535。</p><ol><li>熟知端口号：0-1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20,HTTP使用80，DNS使用53.</li><li>登记端口号：1024-49151，为煤油熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如：Microsoft RDP微软远程桌面使用的端口号是3389.</li><li>短暂端口号：49152-65535，留给客户端进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ol><p>端口号只具有本地意义，即端口号只是为了表示计算机应用层中的个进程，在因特网中，不同计算机中的相同端口号是没有联系的。</p><p><img src="image/image_3.png" alt="image_3"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="image/image_4.png" alt="image_4"></p><p>用户PC，DNS服务器，Web服务器通过交换机进行互联，他们处于同一个以太网中。假设这是Web服务器的域名，DNS服务器中记录有该域名所对应的IP地址。我们在用户PC中使用网页浏览器访问Web服务器的内容。在网页浏览器的地址栏中输入Web服务器域名，用户PC中的DNS客户端进程会发送一个DDNS查询请求报文，其内容为(域名所对应的IP地址是什么？),DNS查询请求报文需要使用运输层的UDP协议，封装成UDP用户数据报，其首部中的源端口字段的值，在短暂端口号49151-65535中挑选一个未被占用的，用来表示DNS客户端进程，例如49152。目的端口字段的值设置为53（DNS服务器端进程所使用的熟知端口号）。</p><p><img src="image/image_5.png" alt="image_5"></p><p>之后将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器，DNS服务器收到该数据报后，从中解封出UDP用户数据报。UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文交付给本服务器中的DNS服务器端进程。DNS服务器端进程解析DNS查询请求报文内容，然后按其要求查找对应的IP地址。之后，会给用户PC发送DNS响应报文，其内容为(域名所对应的IP地址是192.168.0.3)。DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报，其首部中源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报；目的端口字段的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号。</p><p><img src="image/image_6.png" alt="image_6"></p><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC。用户PC收到该数据报后，从中解封出UDP用户数据报。UDP首部汇总的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分也就是DNS响应报文交付给用户PC中的DNS客户端进程。DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名所对应的IP地址为192.168.0.3。</p><p><img src="image/image_7.png" alt="image_7"></p><p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文了。其内容为“首页内容是什么？”HTTP请求报文需要使用运输层的TCP协议封装成TCP报文段，其首部中的源端口字段的值在短暂端口号49151-65535中挑选一个未被占用的，用来表示HTTP客户端进程。例如仍然使用之前用过的49152.目的端口字段的值设置为80，这是HTTP服务器端进程所使用的熟知端口号。</p><p><img src="image/image_8.png" alt="image_8"></p><p>之后，将TCP报文段封装在IP数据报中，通过以太网发送给Web服务器。Web服务器收到该数据报后，从中解封出TCP报文段。TCP首部中的目的端口号为80，这表明应该将TCP报文段的数据载荷部分，也就是HTTP请求报文交付给本服务器中的HTTP服务端进程。HTTP服务器端进程解析HTTP请求报文的内容，然后按其要求查找首页内容。之后，会给用户PC发送HTTP响应报文，其内容是HTTP客户端所请求的首页内容。HTTP响应报文需要使用运输层的TCP协议封装成TCP报文段，其首部中的源端口字段的值设置为熟知端口号80，表明这是HTTP服务端进程所发送的TCP报文段；目的端口字段的值设置为49152，这是之前用户PC中发送HTTP请求报文的HTTP客户端进程，所使用的短暂端口号。</p><p><img src="image/image_9.png" alt="image_9"></p><p>之后将TCP报文段封装在IP数据报中通过以太网发送给用户PC。用户PC收到数据报后，从中解封出TCP报文段。TCP首部中的目的端口号为49152，这表明应将该TCP报文段的数据载荷部分也就是HTTP响应报文交付给用户PC中的HTTP客户端进程。HTTP客户端进程解析HTTP响应报文的内容，并在网页流浪器进行显示。</p><h1 id="UDP和TCP对比"><a href="#UDP和TCP对比" class="headerlink" title="UDP和TCP对比"></a>UDP和TCP对比</h1><ol><li>UDP无连接；TCP面向连接</li></ol><p><img src="image/image_10.png" alt="image_10"></p><p>使用UDP的通信双方，可以随时发送数据；使用TCP的通信双方，在进行数据传输之前，必须使用“三报文握手”来建立TCP连接。TCP连接建立成功后才能进行数据传输。数据传输结束后，必须使用“四报文挥手”来释放TCP连接。</p><ol start="2"><li>UDP支持单播、多播以及广播；TCP支持单播</li></ol><p><img src="image/image_11.png" alt="image_11"></p><ol start="3"><li>UDP面向应用报文；TCP面向字节流</li></ol><p><img src="image/image_12.png" alt="image_12"></p><p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界；发送方的TCP把应用进程交付下来的数据块仅仅看做是一连串的、无结构的字节流，TCP并不知道这些待传送的字节流的含义，仅将它们编号并存储在自己的发送缓存中。TCP根据发送策略从发送缓存中提取一定数量的字节，构建TCP报文段并发送。接收方的TCP一方面从接收到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程。TCP不保证接收方应用进程所收到的数据块与发送方应用进程</p><p>所发出的数据块具有对应大小的关系。但接收方应用进程收到的字节流必须和发送方应用进程发出的字节流完全一样。也就是说TCP是面向字节流的，这正是TCP实现可靠传输、流量控制以及拥塞控制的基础。</p><ol start="4"><li>UDP向上层提供无连接不可靠传输服务；TCP向上层提供面向连接的可靠传输服务</li></ol><p><img src="image/image_13.png" alt="image_13"></p><p>发送方给接收方发送UDP用户数据报，若传输过程中用户数据报受到干扰而产生误码，接收方UDP可以通过该数据报首部中的校验和字段的值检查出产生误码的情况。但仅仅丢弃该数据报，其他什么也不做。发送方给接收方发送UDP数据报，如果该数据报被因特网中的某个路由器丢弃了，发送方UDP不做任何处理，因为UDP向上层提供的是无连接不可靠的传输服务。因此UDP用户数据报出现的误码和丢失等问题，UDP并不关心。基于UDP这个特点，UDP适用于实时应用，例如IP电话、视频会议等。</p><p>尽管网际层中的IP协议向上层提供的是无连接不可靠的传输服务。也就是说，IP数据报可能在传输过程中出现丢失或误码。但只要运输层使用TCP协议，就可向其上层提供面向连接的可靠传输服务。使用TCP协议的收发双方基于TCP连接的可靠信道进行数据传输。不会出现误码、丢失、乱序以及重复等传输差错。</p><p>TCP适用要求可靠传输的应用，例如文件传输等。</p><ol start="5"><li>UDP用户数据报首部仅8个字节；TCP报文首部最小20字节最大60字节</li></ol><p><img src="image/image_14.png" alt="image_14"></p><p>一个UDP用户数据报由首部和数据载荷两部分构成。首部仅有4个字段，每个字段长度为2个字节。由于UDP不提供可靠传输服务，它仅仅在网际层的基础上，添加了用于区分应用进程的端口；</p><p>一个TCP报文段由首部和数据载荷两部分构成，首部其最小长度为20字节，最大60字节，这是因为TCP要实现可靠传输、流量控制、拥塞控制等服务。</p><h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p><img src="image/image_15.png" alt="image_15"></p><p>假设主机A和B是因特网上的两台主机，它们之间已经建立了TCP连接，A给B发送数据，B对A进行流量控制。假设主机A发送的每个TCP数据报文段可携带100字节数据。因此图中每个小个子表示100个字节数据的序号。在主机A和B建立TCP连接时，B告诉A：“我的接收窗口为400”。因此，主机A将自己的发送窗口也设置为400。这意味着主机A在未收到主机B发来的确认时，可将序号落入发送窗口中的全部数据发送出去。</p><p>主机A将发送窗口内序号1-100的数据封装成一个TCP报文段发送出去。发送窗口内容还有300字节可以发送。seq是TCP报文段首部中的序号字段，取值1表示TCP报文段数据载荷的第一个字节的序号是1.</p><p>DATA表示TCP数据报文段。主机A将发送窗口内序号101-200的数据封装成一个TCP报文段发送出去。发送窗口内还有200字节可以发送。主机A将发送窗口内序号201-300的数据封装成一个TCP报文段发送出去。但该报文段在传输过程中丢失了，主机A发送窗口内还有100字节可以发送。主机B对主机A所发送的201号以前的数据进行累计确认。并在该可累计确认中将窗口字段的值调整为300，也就是对主机A进行流量控制。ACK是TCP报文段首部中的标志位，取值1表示这是一个TCP确认报文段。ack是TCP报文段首部中的确认号字段，取值201表示序号201之前的数据已全部正确接收，现在希望收到序号201及其后续数据。rwnd是TCP报文段首部中的窗口字段，取值300表示自己的接收窗口大小为300.</p><p><img src="image/image_16.png" alt="image_16"></p><p>主机A收到该累计确认后，将发送窗口向前滑动，使已发送并确认的这些数据的序号移出发送窗口。由于主机B在该累计确认中将自己的接收窗口调整为了300。因此主机A相应地将自己的发送窗口调整为300.</p><p>目前主机A发送的序号为201-500，也就是主机A还可以发送这300字节。其中201-300号字节是已发送的数据，若重传计时器超时，它们会被重传。301-400号字节以及401-500号字节还未被发送。可被分别封装在一个TCP报文段中发送。主机A现在可发送缓存中序号1-200的字节数据全部删除了，因为已经收到了主机B对它们的累计确认。</p><p><img src="image/image_17.png" alt="image_17"></p><p>主机A将发送窗口内序号301-400的数据封装成一个TCP报文段发送出去。发送窗口内容还有100字节可以发送。主机A将发送窗口内序号401-500的数据封装成一个TCP报文段发送出去。至此，序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了。</p><p><img src="image/image_18.png" alt="image_18"></p><p>现在发送窗口内序号201-300这100个字节数据的重传计时器超时了。主机A将它们重新封装成一个TCP报文段发送出去。暂时不能发送其他数据。主机B收到该重传的TCP报文段后，对主机A所发送的501号以前的数据进行累计确认。并在该累计确认中将窗口字段的值调整为100，这是主机B对主机A进行的第二次流量控制。</p><p><img src="image/image_19.png" alt="image_19"></p><p>主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移出发送窗口。由于主机B在该累计确认中将自己的接收串口调整为了100.因此主机A相应地将自己的发送窗口调整为100.目前主机A发送窗口内容的序号为501-600.也就是主机A还可以发送这100字节。主机A现在可将发送缓存中序号201-500的字节数据全部删除了，因为已经收到了主机B对它们的累计确认。主机A将发送窗口内序号501-600的数据封装成一个TCP报文段发送出去。至此序号落在发送窗口内的数据全部发送出去了，不能再发送新数据了。主机A所发送的601号以前的数据进行累计确认。并在该累计确认中将窗口字段的值调整为0，这是主机B对主机A进行的第三次流量控制。</p><p><img src="image/image_20.png" alt="image_20"></p><p>主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据序号移出发送窗口。由于主机B在该累计确认中将自己的接收窗口调整了0。因此主机A相应地将自己的发送窗口调整为0.目前，主机A不能再发送一般的TCP报文段了。主机A现在可将发送缓存中序号501-600的字节数据全部删除了，因为已经收到了主机B对它们的累计确认。</p><p><img src="image/image_21.png" alt="image_21"></p><p>假设主机B向主机A发送了零窗口的报文段后不久，主机B的接收缓存又有了一些存储空间。于是，主机B向主机A发送了接收窗口等于300的报文段，然而这个报文段在传输过程中丢失了。主机A一直等待主机B发送的非零窗口的通知，主机B也一直等待主机A发送的数据。</p><p>如果不采取措施，这种互相等待而形成的死锁局面将一直持续下去，为了解决这个问题TCP为每一个连接设有一个持续计时器，只要TCP连接的一放收到对方的零窗口通知，就启动持续及时器。若持续计时器超时，就发送一个零窗口探测报文，仅携带一字节的数据。而对方在确认这个探测报文段时，给出自己现在的接收窗口值。如果接收窗口仍然为0，那么收到这个报文段的一方就重新启动持续及时器；如果接收窗口不是0，那么死锁的局面就可以被打破了。 </p><p>在本例中，主机A收到零窗口通知时，就启动一个持续计时器。当持续计时器超时，主机A立刻发送一个仅携带一字节数据的零窗口探测报文段。假设主机B此时的接收窗口又为0了，主机B就在确认这个零窗口探测报文段时，给出自己现在的接收窗口值为0。主机A再次受到零窗口通知，就再次启动一个持续计时器。当持续计时器超时，主机A立刻发送一个零窗口探测报文段。假设主机B此时的接收缓存又有一些存储空间，于是将自己的接收窗口调整为了300，主机B就在确认这个零窗口探测报文段时给出自己现在的接收窗口值为300.这样就打破了死锁的局面。</p><p>TCP规定即使接收窗口为0，也必须接收零窗口探测报文段、确认报文段以及携带有紧急数据的报文段。如果零窗口报文段丢失也可打破死锁局面，因为零窗口报文段也有重传计时器，当重传计时器超时后，零窗口报文段会被重传。</p><p><img src="image/image_22.png" alt="image_22"></p><h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种强开就叫做拥塞。若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷增大而下降。</p><blockquote><p>网络的资源：在计算机网络中的链路容量（即宽带）、交换结点中的缓存和处理机等，都是网络的资源。</p></blockquote><p><img src="image/image_23.png" alt="image_23"></p><p>输入负载代表单位时间内输入给网络的分组数量；吞吐量代表单位时间内网络输出的分组数量。具有理想拥塞控制的网络，在吞吐量达到饱和之前，网络吞吐量应等于所输入的负载，故吞吐量曲线是45度的斜线。但当输入负载超过某一限度时，由于网络资源受限吞吐量就不再增长而保持水平线（即吞吐量达到饱和），这就表明输入的负载中有一部分损失掉了。然而实际的网络情况，随着输入负载的增大，网络吞吐量的增长率逐渐减小，也就是在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了；当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了轻度拥塞的状态。当输入负载到达某一数值时，网络的吞吐量反而随输入负载的增大而减小，这时网络就进入了拥塞状态。当输入负载继续增大到某一数值时，网络的吞吐量就减小为0，此时网络就无法工作了（死锁）。因此进行拥塞控制是十分必要的，实际的拥塞控制应该尽量接近理想的拥塞控制曲线。</p><h2 id="四种拥塞控制算法"><a href="#四种拥塞控制算法" class="headerlink" title="四种拥塞控制算法"></a>四种拥塞控制算法</h2><p>举例假定如下条件：</p><ol><li>数据是单方向传送，而另一个方向只传送确认</li><li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li><li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。</li></ol><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p><img src="image/image_24.png" alt="image_24"></p><p><img src="image/image_25.png" alt="image_25"></p><p>TCP发送方一开始使用慢开始算法，让拥塞窗口值从1开始按指数规律增大。当拥塞窗口值增大到慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大。当发生超时重传时，就判断网络很可能出现了拥塞。采取相应措施，一方面将慢开始门限值更新为发生拥塞窗口值的一半；另一方面将拥塞窗口值减少为1，并重新开始执行慢开始算法。拥塞窗口值又从1开始按指数规律增大。当增大到了新的慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大。</p><p>慢开始是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；</p><p>拥塞避免并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法。1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是快重传和恢复。有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞；这将导致发送方超时重传，并误认为网络发生了拥塞；发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率。</p><p><img src="image/image_26.png" alt="image_26"></p><p>所谓快重传就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p><ol><li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；</li><li>及时收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</li><li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。使用快重传可以使整个网络的吞吐量提高约为20%。</li></ol><p><img src="image/image_27.png" alt="image_27"></p><p>发送方发送1号数据报文段，接收方收到后给发送方发回对1号报文段的确认。在该确认报文段到达发送方之前，发送方还可以将发送窗口内的2号数据报文段发送出去。接收方收到后给发送方发回对2号报文段的确认。在该确认报文段到达发送方之前，发送方还可以将发送窗口内的3号数据报文段发送出去，但该报文段丢失了，接收方自然不会给发送方发回针对该报文段的确认。发送方还可以将发送窗口内的4好数据报文段发送出去。接收方收到后发现这不是按序到达的报文段，因此给发送方发回针对2号报文段的重复确认（表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而是收到了未按序到达的报文段）。发送方还可以将发送窗口内的5号数据报文段发送出去，接收方收到后发现不是按序到达的报文段，因此给发送方发回针对2号报文段的重复确认。发送方还可以将发送窗口内的6号数据报文段发送出去。接收方收到后发现不是按序到达报文段，因此给发送方发回针对2号报文段的重复确认。至此发送方会收到3个连续的对2号报文段的重复确认就立即重传3号报文段，接收方收到后，给发送方发回针对6号报文段的确认，这样就不会造成对3号报文段的超时重传，而是提早进行了重传。</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而是执行快恢复算法；发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；开始执行拥塞避免算法。也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值在增大一些，即等于新的ssthresh+3.</p><ol><li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络；</li><li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</li><li>可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</li></ol><h2 id="结合四种拥塞算法举例"><a href="#结合四种拥塞算法举例" class="headerlink" title="结合四种拥塞算法举例"></a>结合四种拥塞算法举例</h2><p><img src="image/image_28.png" alt="image_28"></p><p>TCP发送方一开始使用慢开始算法，让拥塞窗口值从1开始按指数规律增大。当拥塞窗口值增大到慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大。当发生超时重传时，就判断网络很可能出现了拥塞。采取相应措施，一方面将慢开始门限值更新为发生拥塞窗口值的一半；另一方面将拥塞窗口值减少为1，并重新开始执行慢开始算法。拥塞窗口值又从1开始按指数规律增大。当增大到了新的慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大。</p><p>当发送方收到3个重复确认时，就进行快重传和快恢复（更新慢开始门限值为当前拥塞窗口值的一半，并将拥塞窗口值也取值为新的慢开始门限值，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大）。</p><p><img src="image/image_29.png" alt="image_29"></p><h1 id="超时重传时间选择"><a href="#超时重传时间选择" class="headerlink" title="超时重传时间选择"></a>超时重传时间选择</h1><h2 id="问题举例"><a href="#问题举例" class="headerlink" title="问题举例"></a>问题举例</h2><h3 id="问题举例一"><a href="#问题举例一" class="headerlink" title="问题举例一"></a>问题举例一</h3><p><img src="image/image_30.png" alt="image_30"></p><p>假设主机A和B是因特网上的两台主机，它们之间已经建立了TCP连接。纵坐标为时间，主机A给主机B发送TCP数据报文段0并记录下当前的时间。主机B收到后，给主机A发送相应的确认报文段。主机A收到确认报文段后，记录下当前的时间。主机A记录下的两个时间的差值就是报文段往返时间RTT0。</p><p>如果超时重传时间RTO的值设置的比RTT0的值小，会引起报文段不必要的重传，使网络负荷增大；</p><p><img src="image/image_31.png" alt="image_31"></p><p>如果将超时重传时间RTO的值设置的远大于RTT0的值，会使重传推迟时间太长，导致网络的空闲时间增大，降低了传输效率。因此，超时重传时间RTO的值应略大于往返时间RTT。</p><p><img src="image/image_32.png" alt="image_32"></p><p>往返时间RTT1远大于RTT0，如果超时重传时间RTO，还是我们之前所确定的略大于RTT0的话，这对于数据报文段1是不合适的，会造成该报文段不必要的重传。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。</li><li>利用每次测量得到的RTT样本，计算加权平均往返时间RTTs（平滑的往返时间）<br>  RTTs1 = RTT1<br>  新的RTTs = （1-α）x 旧的RTTs + α x 新的RTT样本（0 ≤ α &lt;1）<br>  若α很接近0，则新RTT样本对RTTs的影响不大；<br>  若α很接近1，则新的RTT样本对RTTs的影响较大；<br>  已成为标准的RFC6298推荐α值为1/8，即0，125.</li><li>超时重传时间RTO应略大于加权平均往返时间RTTs。</li></ul><p><img src="image/image_33.png" alt="image_33"></p><h3 id="问题举例二"><a href="#问题举例二" class="headerlink" title="问题举例二"></a>问题举例二</h3><p><img src="image/image_34.png" alt="image_34"></p><p>情况一：主机A给主机B发送TCP数据报文段，但该报文段在传输过程中丢失了。当超时重传及时器超时后，主机A就重传该报文段，主机B收到后，给主机A发送确认报文段。但主机A收到确认报文段后，无法判断报文段是对原报文段的确认还是对重传报文段的确认。源主机若误将确认当作是对原报文段的确认：所计算出的RTTs和RTO就会偏大，降低了传输效率。</p><p>情况二：主机A给主机B发送TCP数据报文段，主机B收到后，给主机A发送确认报文段。由于某种原因，该确认报文段没有在正常时间内到达主机A，这必然会导致主机A对之前所发送的数据报文段的超时重传。主机A收到迟到的确认报文段后，无法判断该报文段是对原报文段的确认，还是对重传报文段的确认。源主机若误将确认当做是对重传报文段的确认，所计算出的RTTs和RTO就会偏小，导致报文段没必要的重传，增大网络负荷。</p><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>针对出现超时重传时无法推测往返时间RTT的问题，Karn提出了一个算法：在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。da</p><p>但这会引起新的问题：报文段的时延突然增大了很多，并且之后很长一段时间都保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新，会导致报文段反复被重传。</p><p>因此，对Karn算法进行修正：报文段每重传一次，就把超时重传时间RTO增大一些。如将新RTO的值取为旧RTO值的2倍。</p><h2 id="举例超时重传计算"><a href="#举例超时重传计算" class="headerlink" title="举例超时重传计算"></a>举例超时重传计算</h2><p><img src="image/image_35.png" alt="image_35"></p><h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><p>TCP基于以字节为而单位的滑动窗口来实现可靠传输。</p><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><p><img src="image/image_36.png" alt="image_36"></p><p>发送方待发送数据字节的序号。</p><p><img src="image/image_37.png" alt="image_37"></p><p>在报文段首部中的窗口字段的值为20，也就是接收方表明自己的接收窗口的尺寸为20字节。确认号字段的值为31，这表明接收方希望收到下一个数据的序号是31，而序号30为止的数据已经全部正确接收了。因此发送方根据这两个字段的值构造出自己的发送窗口。</p><p><img src="image/image_38.png" alt="image_38"></p><p>接收方告诉发送方自己的接收窗口尺寸为20，因此发送方将自己的发送窗口尺寸也设置为20.发送方在没有收到接收方确认的情况下，可以把发送窗口内的数据一次全部发送出去，凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用。</p><p><img src="image/image_39.png" alt="image_39"></p><p>假定发送方将发送窗口内序号31-41的数据封装在几个不同的报文段中发送出去，此时发送窗口的位置并没有改变。发送窗口内31-41的数据已经发送但未收到确认，而序号42-50的数据是允许发送但未发送的。</p><p><img src="image/image_40.png" alt="image_40"></p><p>假设发送方之前发送的封装有32和33号数据的报文段到达了接收方，由于数据序号落在接收窗口内，所以接收方接受它们，并将它们存入缓存。但是它们是未按序到达的数据，因为31号数据还没有到达，这有可能是丢了或者滞留在网络中的某处。</p><p><img src="image/image_41.png" alt="image_41"></p><p>接收方只能对按序收到的数据中最高序号给出确认，因此接收方发出的确认报文段中的确认序号仍然是31。发送方收到该确认报文段后，发现这是一个针对31号数据的重复确认，就知道接收方收到了未按序到达的数据。由于这是针对31号数据的第一个重复确认，因此这并不会引起发送方针对该数据的快重传。另外，接收方通知得到窗口尺寸仍是20，因此发送方仍保持自己的发送窗口尺寸为20.</p><p><img src="image/image_42.png" alt="image_42"></p><p>现在假设封装有31号数据的报文段到达了接收方，接收方接受该报文段。</p><p><img src="image/image_43.png" alt="image_43"></p><p>将其封装的31号数据存入接收缓存。接收方现在可将接收到的31-33号数据交付给应用进程。</p><p><img src="image/image_44.png" alt="image_44"></p><p>然后将接收窗口向前移动3个序号，并给发送方发送确认报文段，确认报文段中窗口字段的值为20，确认号字段的值为34.</p><p><img src="image/image_45.png" alt="image_45"></p><p>现在，假设又有几个数据报文段到达了接收方，它们封装有37，38以及40号数据。这些数据的序号虽然落在接收窗口内，但它们都是未按序到达的数据，只能先暂存在接收缓存中。</p><p><img src="image/image_46.png" alt="image_46"></p><p>假设接收方先前发送的确认报文段到达了发送方。发送方接收后，将发送窗口向前滑动3个序号，这样有新序号52-53落入发送窗口内。发送方继续将发送窗口内序号42-53的数据封装在几个不同的报文段中发送出去。现在，至此窗口内的序号已经用完了，发送方在未收到接收方发来确认的情况下，不能再发送新得到数据。序号落在发送窗口内的已发送数据，如果迟迟收不到接收方的确认，则会产生超时重传。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。<br>  网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。<br>  发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。</li><li>对于不按序到达的数据应如何处理，TCP并无明确规定。<br>  如果接收方把不按序到达的数据一律丢失，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。<br>  TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP要求接收方必须有累计确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便带上。<br>  接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认【RFC 1122】。<br>  捎带确认实际上并不经常发生，因为大多数应用程序很好同时在两个方向上发送数据。</li><li>TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。</li></ul><p><img src="image/image_47.png" alt="image_47"></p><p><img src="image/image_48.png" alt="image_48"></p><h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><ul><li>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</li><li>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</li><li>TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行。</li><li>TCP运输连接有三个阶段:建立TCP连接、数据传送和释放TCP连接。</li></ul><p><img src="image/image_49.png" alt="image_49"></p><ul><li>TCP的连接建立要解决以下三个问题：</li></ul><ol><li>使TCP双方能够确认对方的存在；</li><li>使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</li><li>使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ol><ul><li>TCP使用“三报文握手”建立连接</li></ul><p><img src="image/image_50.png" alt="image_50"></p><p>其中一台主机中的某个应用进程主动发起TCP连接建立，称为TCP客户；另一台主机中被动等待TCP连接建立的应用进程，称为TCP服务器。“握手”需要在TCP客户和服务器之间交换三个TCP报文段。最初，两端的TCP进程都处于关闭状态。一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息，例如：TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前发送和接收序号等。之后，就准备接受TCP客户进程的连接请求。此时，TCP服务器进程就进入监听状态，等待TCP客户进程的TCP请求。</p><p><img src="image/image_51.png" alt="image_51"></p><p>TCP服务器进程是被动等待来自TCP客户进程的连接请求，而不是主动发起，因此称为被动打开连接。TCP客户进程也是首先创建传输控制块。</p><p><img src="image/image_52.png" alt="image_52"></p><p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段并进入同步已发送状态。TCP连接请求报文段首部中的同步位SYN被设置为1，表明这是一个TCP连接请求报文段，序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号。由于TCP连接建立是由TCP客户主动发起的，因此称为主动打开连接。</p><blockquote><p>TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号。</p></blockquote><p><img src="image/image_53.png" alt="image_53"></p><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户端进程发送TCP连接请求确认报文段，并进入同步已接收状态。该报文段首部中的同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段。序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号。确认号字段ack的值被设置成了x+1，这是对TCP客户端进程所选择的初始序号的确认。</p><blockquote><p>该报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗一个序号。</p></blockquote><p><img src="image/image_54.png" alt="image_54"></p><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已建立状态。该报文段首部中的确认位ACK被设置为1，表明这是一个普通的TCP确认报文段。序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，并且不携带数据，因此第二个报文段的序号为x+1.确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认。</p><blockquote><p>TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号。在这种情况下，所发送的下一个数据报文段的序号仍为x+1.</p></blockquote><p><img src="image/image_55.png" alt="image_55"></p><p>TCP服务器进程收到该确认报文段也进入连接已建立状态。现在TCP双方都进入了连接已建立状态。它们可以基于已建立好的TCP连接，进行可靠的数据传输了。</p><ul><li>能否使用“两报文握手”建立连接？</li></ul><p><img src="image/image_56.png" alt="image_56"></p><p>TCP客户进程发出一个TCP连接请求报文段，但该报文段在某些网络结点长时间滞留了，这必然会造成该报文段的超时重传。假设重传的报文段被TCP服务器进程正常接收。TCP服务器进程给TCP客户进程发送一个TCP连接请求确认报文段，并进入链接已建立状态。TCP客户进程收到TCP连接请求确认报文段后，进入TCP连接已建立状态，但不会给TCP服务器进程发送针对该报文段的普通确认报文段。现在TCP双方都处于连接已建立状态，它们可以相互传输数据，之后，可以通过“四报文挥手”来释放连接，这样TCP双方都进入了关闭状态。</p><p><img src="image/image_57.png" alt="image_57"></p><p>一段时间后，之前滞留在网络中的那个失效的TCP连接请求报文段到达了TCP服务器进程。TCP服务器进程会误认为这是TCP客户进程，又发起了一个新的TCP连接请求，于是给TCP客户进程发送TCP连接请求确认报文段，并进入连接已建立状态。该报文段到达TCP客户进程，有TCP客户进程并没有发起新的TCP连接请求，并且处于关闭状态，因此不会理会该报文段。但TCP服务器进程已进入连接已建立状态，它认为新的TCP连接已建立好了，并一直等待TCP客户进程发来数据，这将白白浪费TCP服务器进程所在主机的很多资源。</p><p>综上所述，采用“三报文握手”而不是“两报文握手”来建立TCP连接，是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误。</p><p><img src="image/image_58.png" alt="image_58"></p><h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p><img src="image/image_59.png" alt="image_59"></p><p>数据传输结束后，TCP通信双方都可以释放连接。现在TCP客户进程和TCP服务器进程都处于连接已建立状态。假设使用TCP客户进程的应用进程通知其主动关闭TCP连接，TCP客户进程会发送TCP连接释放报文段并进入终止等待1状态。该报文段首部中的终止为FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认。序号seq的字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1.确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的数据的最后一个字节的序号加1.</p><blockquote><p>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</p></blockquote><p><img src="image/image_60.png" alt="image_60"></p><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</p><p>该报文段首部中的确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段。序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过得数据的最后一个字节的序号加1。这也与之前收到的TCP连接上方报文段中的确认号匹配。确认号ack字段的值设置为u+1,这是对TCP连接释放报文段的确认。</p><p><img src="image/image_61.png" alt="image_61"></p><p>TCP服务器进程这时应通知高层应用进程：TCP客户进程要断开与自己的TCP连接。此时，从TCP客户进程到TCP服务进程这个方向的连接就释放了。这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了，但TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收。也就是说，从TCP服务器进程到TCP客户进程这个方向的连接并未关闭。</p><p><img src="image/image_62.png" alt="image_62"></p><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态。等待TCP服务器进程发出的TCP连接释放报文段。若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</p><p><img src="image/image_63.png" alt="image_63"></p><p><img src="image/image_64.png" alt="image_64"></p><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态，该报文段首部中的终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认。现在假定序号seq字段的值为w。这是因为在半关闭状态下，TCP服务器进程可能又发送了一些数据。确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p><p><img src="image/image_65.png" alt="image_65"></p><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。该报文段首部中的确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段。序号seq字段的值设置为u+1,这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号。确认好ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</p><p><img src="image/image_66.png" alt="image_66"></p><p>TCP服务器进程收到该报文段后就进入关闭状态。而TCP客户进程还要经过2MSL后才能进入关闭状态。</p><blockquote><p>MSL（Maximum Segment Lifetime）是最长报文段寿命，RFC793建议为2分钟。</p></blockquote><ul><li>TCP客户进程在发送完最后最后一个确认报文段后，为什么不直接进入关闭状态，而是要进入时间等待状态？</li></ul><p><img src="image/image_67.png" alt="image_67"></p><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态，TCP客户进程收到TCP连接释放报文段后，发送普通的TCP确认报文段，并进入关闭状态，而不是时间等待状态。然而该TCP确认报文段丢失了，这必然会造成TCP服务器进程对之前所发送的TCP连接释放报文段的超时重传，并仍处于最后确认状态，重传的TCP连接释放报文段到达TCP客户进程，由于TCP客户进程属于关闭状态，因此不理睬该报文段，这必然会造成TCP服务器进程反复重传TCP连接释放该报文段，并一直处于最后确认状态而无法进入关闭状态。</p><p>因此，时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p><h2 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h2><p>TCP双方已经建立了连接，后来TCP客户进程所在的主机突然出现了故障。TCP服务器进程以后就不能再收到TCP客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。</p><ol><li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动报活计时器（2小时定时）。</li><li>若保活计时器定时周期内未红素到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</li></ol><h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><p>为了实现可靠传输，TCP采用了面向字节流的方式。但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送。一个TCP报文段由首部和数据载荷两部分构成；TCP的全部功能都体现在它首部中各字段的作用。</p><h2 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="image/image_68.png" alt="image_68"></p><p>源端口：占16比特，写入源端口号，用来表示发送该TCP报文段的应用进程。</p><p>目的端口：占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程。</p><h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><p><img src="image/image_69.png" alt="image_69"></p><p>仅从运输层端口号这个角度举例说明，当在浏览器地址栏中输入Web服务器的域名后，浏览器进程会构建一个封装有HTTP请求报文的TCP报文段 ，该报文段首部中的源端口字段会填写一个短暂端口号，例如49152，用来标识发送该报文段的浏览器进程。目的端口号字段会填写熟知端口号80，因为使用HTTP协议的Web服务器进程默认监听该端口。</p><p><img src="image/image_70.png" alt="image_70"></p><p>Web服务器收到该TCP报文段后，从中解封出HTTP请求报文，并根据TCP报文段首部中目的端口字段的值80，将HTTP请求报文上交给Web服务器进程。</p><p><img src="image/image_71.png" alt="image_71"></p><p>Web服务器进程根据HTTP请求报文的内容进行相应处理，并构建一个HTTP响应报文，HTTP响应报文需要封装成TCP报文段进行发送。该报文段首部中的源端口字段会填写熟知端口号80，用来标识发送该TCP报文段的Web服务器进程。而目的端口字段会填写49152，这是主机中需要接收该TCP报文段的浏览器进程所对应的端口号。</p><p><img src="image/image_72.png" alt="image_72"></p><p>主机收到该TCP报文段后，从中解封出HTTP响应报文，并根据TCP报文段首部中目的端口字段的49152，将HTTP响应报文上交给浏览器进程。浏览器进程对HTTP响应报文的内容进行解析并显示。</p><h2 id="序号、确认号和ACK"><a href="#序号、确认号和ACK" class="headerlink" title="序号、确认号和ACK"></a>序号、确认号和ACK</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><img src="image/image_73.png" alt="image_73"></p><p>序号：占32比特，取值范围[0,2的32次-1]，序号增加到最后一个后，下一个序号就又回到0.指出本TCP报文段的数据载荷的第一个字节的序号。</p><p><img src="image/image_74.png" alt="image_74"></p><p>例如TCP报文段，由首部和数据载荷两部构成，数据载荷中的每个字节数据都有序号，首部中序号字段应填入的十进制值为166，用来指出数据载荷的第一个字节的序号为166.</p><p>确认号：占32比特，取值范围[0,2的32次-1]，确认号增加到最后一个后，下一个确认就又回到0.指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。</p><p>若确认号为n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。</p><p>确认标志位ACK：取值为1时确认号字段才有效；取值为0时确认好字段无效。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1.</p><h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p><img src="image/image_75.png" alt="image_75"></p><p>TCP客户进程发送一个TCP报文段，该报文段首部中序号字段的取值为201，这表示该TCP报文段数据载荷的第一个字节的序号为201.假设数据载荷长度为100字节，首部中确认号字段的取值为800，这表示TCP客户进程收到了TCP服务器进程发来的序号到799为止的全部数据，现在期望收到序号从800开始的数据。为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1。</p><p><img src="image/image_76.png" alt="image_76"></p><p>TCP服务器进程收到该报文段后，也给TCP客户进程发送TCP报文段，该报文段首部中序号字段取值为800，这表示该TCP报文段数据载荷的第一个字节的序号为800，这正好用户TCP客户进程的确认相匹配。假设数据载荷的长度为200字节，首部中确认号字段的取值为301，这表示TCP服务器进程收到了TCP客户进程发来的序号到300为止的全部数据，现在期望收到序号从301开始的数据，为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1。</p><h2 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p><img src="image/image_77.png" alt="image_77"></p><p>数据偏移：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上指出了TCP报文段的首部长度。首部固定长度为20字节，因此数据偏移字段的最小值为二进制0101；首部最大长度为60字节，因此数据偏移字段的最大值为二进制1111（15个长度单位=15<em>32位=15</em>4字节）</p><h3 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h3><p><img src="image/image_78.png" alt="image_78"></p><h2 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h2><p><img src="image/image_79.png" alt="image_79"></p><p>保留：占6比特，保留为今后使用，目前应置为0.</p><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p><img src="image/image_80.png" alt="image_80"></p><p>窗口：占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。这是以接收方的接收能力来控制发送方的发送能力，称为流量控制。</p><blockquote><p>发送窗口的大小还取决于拥塞窗口的大小，也就是应该从接收窗口和拥塞窗口中取小者。</p></blockquote><h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p><img src="image/image_81.png" alt="image_81"></p><p>校验和：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和是，要在TCP报文段的前面加上12字节的伪首部。</p><h2 id="SYN"><a href="#SYN" class="headerlink" title="SYN"></a>SYN</h2><p><img src="image/image_82.png" alt="image_82"></p><p>同步标志位SYN：在TCP连接建立时用来同步序号。</p><h2 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h2><p><img src="image/image_83.png" alt="image_83"></p><p>终止标志位FIN：用来释放TCP连接。</p><h2 id="RST"><a href="#RST" class="headerlink" title="RST"></a>RST</h2><p><img src="image/image_84.png" alt="image_84"></p><p>复位标志位RST：用来复位TCP连接。当RST=1时，表明TCP连接出现了异常，必然释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</p><h2 id="PSH"><a href="#PSH" class="headerlink" title="PSH"></a>PSH</h2><p><img src="image/image_85.png" alt="image_85"></p><p>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。</p><h2 id="URG和紧急指针"><a href="#URG和紧急指针" class="headerlink" title="URG和紧急指针"></a>URG和紧急指针</h2><p><img src="image/image_86.png" alt="image_86"></p><p>紧急标志位URG：取值为1时紧急指针字段有效；取值为0时紧急指针字段无效。</p><p>紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。</p><p>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急微数据，紧急数据之后是普通数据。x</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><img src="image/image_87.png" alt="image_87"></p><p>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。</p><p>窗口扩大选项：为了扩大窗口（提高吞吐率）。</p><p>时间戳选项：用来计算往返时间RTT；用来处理序号超范围的情况，又称防止序号绕回PAWS。</p><h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p><img src="image/image_88.png" alt="image_88"></p><p>填充：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除（因为数据偏移字段，也就是首部长度字段，是以4字节为单位的）。</p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.icourse163.org/course/HNKJ-1461816178">计算机网络_湖南科技大学_中国大学MOOC(慕课) (icourse163.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="https://github.com/LittleWills/GameWill.github.io.git/2021/12/26/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>https://github.com/LittleWills/GameWill.github.io.git/2021/12/26/%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2021-12-26T12:33:10.000Z</published>
    <updated>2022-04-23T10:05:30.747Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>网络层的主要任务是实现网络互连，进而实现数据报在各网络之间的传输。因特网是目前全世界用户数量最多的互联网，它使用TCP/IP协议栈。由于TCP/IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为网际层。</p></blockquote><span id="more"></span><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><p>网络层的主要任务是实现网络互连，进而实现数据报在各网络之间的传输。</p><p>要实现网络层的任务，需要解决以下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li><li>网络层寻址问题</li><li>路由选择问题</li></ul><p>因特网是目前全世界用户数量最多的互联网，它使用TCP/IP协议栈。由于TCP/IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为网际层。</p><h1 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h1><h2 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h2><p><img src="image/image.png" alt="image"></p><ul><li>可靠通信由网络来保证</li><li>必须建立网络层的连接—虚电路VC</li><li>通信双方沿着已建立的虚电路发送分组</li><li>目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号）。</li><li>这种通信方式如果在使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复）</li><li>通信借宿后需要释放之前所建立的虚电路。</li></ul><h2 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h2><p><img src="image/image_1.png" alt="image"></p><ul><li>可靠通信应当由用户主机保证</li><li>不需要建立网络层连接</li><li>每个分组可走不同的路径</li><li>每个分组的首部必须携带目的主机的完整地址</li><li>这种通信方式所传送分组可能误码、丢失、重复和失序</li><li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）</li><li>因特网采用了这种设计思路，将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能至于因特网核心。</li></ul><h1 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IPv4地址就是给因特网上的每一台主机（或路由器）的每一个接口分配一个再全世界范围内是唯一的32比特的标识符。IPv4地址的编址方法激励了如下三个历史阶段：</p><p><img src="image/image_2.png" alt="image"></p><p>32比特的IPv4地址不方便阅读、记录以及输入等，因此IPv4地址采用点分十进制表示方法以方便用户使用：</p><p><img src="image/image_3.png" alt="image"></p><p>8位无符号二进制整数转十进制数</p><p><img src="image/image_4.png" alt="image"></p><p>十进制正整数转8位无符号二进制数</p><p><img src="image/image_5.png" alt="image"></p><h2 id="分类编址的IPv4地址"><a href="#分类编址的IPv4地址" class="headerlink" title="分类编址的IPv4地址"></a>分类编址的IPv4地址</h2><p><img src="image/image_6.png" alt="image"></p><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p><img src="image/image_7.png" alt="image"></p><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p><img src="image/image_8.png" alt="image"></p><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p><img src="image/image_9.png" alt="image"></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><img src="image/image_10.png" alt="image"></p><p><img src="image/image_11.png" alt="image"></p><p><img src="image/image_12.png" alt="image"></p><h2 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h2><p><img src="image/image_13.png" alt="image"></p><p><img src="image/image_14.png" alt="image"></p><p>32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号</p><ul><li>子网掩码使用连续的比特1来对应网络号和子网号</li><li>子网掩码使用连续的比特0来对应主机号</li><li>将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址</li></ul><p><img src="image/image_15.png" alt="image"></p><p><img src="image/image_16.png" alt="image"></p><p>默认的子网掩码是指在未划分子网的情况下使用的子网掩码</p><p><img src="image/image_17.png" alt="image"></p><h2 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>划分子网在一定程度上环节了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址空间太小并没有得到充分使用，而因特网的IP地址仍在加速消耗，整个IPv4地址空间面临全部耗尽的威胁。</p><p>1993年，IETF发布了无分类域间路由选择CIDR的RFC文档：RFC1517~1519和1520。</p><ul><li>CIDR消除了传统的A类、B类和C类地址，以及划分子网的概念；</li><li>CIDR可以更加有效地分配IPv4的地址空间，并且可以在新的IPv6使用之前允许因特网的规模继续增长。</li></ul><p><img src="image/image_18.png" alt="image"></p><p>CIDR使用“斜线记法”，或称CIDR记法。即在IPv4地址后面加上斜线“/”,在斜线后面写上网络前缀所占的比特数量。实际上是将网络前缀都相同的连续的IP地址组成一个“CIDR地址快”。我们只要知道CIDR地址快中的任何一个地址，就可以知道该地址的全部细节：地址块的最小地址、地址快的最大地址、地址块中的地址数量、地址块聚合某类网络（A类、B类或C类）的数量、地址掩码（也可称为子网掩码）</p><p><img src="image/image_19.png" alt="image"></p><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p><img src="image/image_20.png" alt="image"></p><p>网络前缀越长，地址块越小，路由越具体；若路由器查表转发分组时发现多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配，因为这样的路由更具体。</p><p><img src="image/image_21.png" alt="image"></p><p><img src="image/image_22.png" alt="image"></p><h2 id="IPv4地址应用规划"><a href="#IPv4地址应用规划" class="headerlink" title="IPv4地址应用规划"></a>IPv4地址应用规划</h2><h3 id="定长的子网掩码FLSM"><a href="#定长的子网掩码FLSM" class="headerlink" title="定长的子网掩码FLSM"></a>定长的子网掩码FLSM</h3><p>使用一个子网掩码来划分子网；每个子网所分配的IP地址数量相同，造成IP地址的浪费。</p><p><img src="image/image_23.png" alt="image"></p><p><img src="image/image_24.png" alt="image"></p><p><img src="image/image_25.png" alt="image"></p><p><img src="image/image_26.png" alt="image"></p><h3 id="变长的子网掩码VLSM"><a href="#变长的子网掩码VLSM" class="headerlink" title="变长的子网掩码VLSM"></a>变长的子网掩码VLSM</h3><p>使用不同的子网掩码来划分子网，每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费。</p><p><img src="image/image_27.png" alt="image"></p><p><img src="image/image_28.png" alt="image"></p><h1 id="IP数据报到发送和转发过程"><a href="#IP数据报到发送和转发过程" class="headerlink" title="IP数据报到发送和转发过程"></a>IP数据报到发送和转发过程</h1><p>IP数据报的发送和转发过程包含以下两部分：主机发送IP数据报、路由转发IP数据报。</p><p><img src="image/image_29.png" alt="image"></p><p><img src="image/image_30.png" alt="image"></p><p>同一个网络中的主机之间可以直接通信，属于直接交付；不同网络中的主机之间的通信，需要通过路由器来中转，属于间接交付。</p><p><strong>源主机如何知道目的主机是否与自己在同一个网络中？</strong></p><p><img src="image/image_31.png" alt="image"></p><p>假设主机C给主机F发送IP数据报，主机C将自己的IP地址和子网掩码相与，就可以得到主机C所在网络的网络地址。主机C将主机F的IP地址与自己的子网掩码相与，就可得到目的网络地址。该地址与主机C的网络地址不相等，因此主机C就知道了主机F与自己不在同一个网络。它们之间的通信属于间接交付。</p><p>主机C需要把IP数据报传输给路由器，由路由器将IP数据报转发给主机F。</p><p><strong>主机C如何知道路由器R的存在？</strong></p><p><img src="image/image_32.png" alt="image"></p><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络中的一个路由器，由该路由器帮忙进行转发。所指定的路由器，也被称为默认网关。我们可以将路由器接口0和1的IP地址，指定给该接口所直连网络中的各个主机作为默认网关。</p><p>当本网络中的主机要和其他网络中的主机进行通信时，会将IP数据报传输给默认网关，由默认网关帮主机将IP数据报转发出去。</p><p><strong>路由器收到IP数据报后如何转发？</strong></p><p>假设主机A要给主机D发送IP数据报，主机A会将该IP数据报传输给自己的默认网关。</p><ul><li>检查IP数据报首部是否出错：若出错，则直接丢弃该IP数据报并通告源主机；若没有出错，则进行转发。</li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：若找到匹配得到条目，则转发给条目中指示的下一跳；若找不到，则丢弃该IP数据报并通告源主机。</li></ul><p><img src="image/image_33.png" alt="image"></p><p>当我们给路由器的接口配置IP地址和子网掩码时，路由器就知道了自己的该接口与哪个网络是直连的。</p><p><img src="image/image_34.png" alt="image"></p><p>路由器根据IP数据报的目的地址，在自己的路由表中查找匹配的路由条目，逐条检查路由条目。将目的地址与路由条目中的地址掩码相与得到目的网络地址。</p><p><img src="image/image_35.png" alt="image"></p><p>假设主机A给本网络上的各设备发送了一个广播IP数据报。该网络中的各设备都会受到该广播IP数据报。但是路由器收到后并不会转发该数据报，路由器是隔离广播域的。</p><p><strong>练习</strong></p><p><img src="image/image_36.png" alt="image"></p><p><img src="image/image_37.png" alt="image"></p><p><img src="image/image_38.png" alt="image"></p><h1 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h1><p>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表。这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化。一般只在小规模网络中采用。</p><p>使用静态路由配置可能出现以下导致产生路由环路的错误：配置错误、聚合了不存在的网络、网络故障。</p><h2 id="静态路由配置-1"><a href="#静态路由配置-1" class="headerlink" title="静态路由配置"></a>静态路由配置</h2><p><img src="image/image_39.png" alt="image"></p><p><img src="image/image_40.png" alt="image"></p><h2 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h2><p><img src="image/image_41.png" alt="image"></p><p>由于因特网中包含了众多的网络，如果给R1添加针对这些网络的每一条路由条目，则会给人工配置带来巨大的工作量，并且使R1的路由表变得非常大，降低了查表转发速度。对于具有相同下一跳的不同目的网络的路由条目，可以用一条默认路由条目来替代。对于本例，配置了默认路由，可以删除第三条路由。</p><h2 id="特定主机路由"><a href="#特定主机路由" class="headerlink" title="特定主机路由"></a>特定主机路由</h2><p><img src="image/image_42.png" alt="image"></p><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目。一般用于网络管理人员对网络的管理和测试。特定主机路由的目的网络前缀最长，路由最具体；默认路由的目的网络网络前缀最短，路由最模糊。当路由器查表转发IP数据报时，若有多条路由条目可选，则使用最长前缀匹配。</p><h2 id="路由环路问题"><a href="#路由环路问题" class="headerlink" title="路由环路问题"></a>路由环路问题</h2><h3 id="静态路由配置错误"><a href="#静态路由配置错误" class="headerlink" title="静态路由配置错误"></a>静态路由配置错误</h3><p><img src="image/image_43.png" alt="image"></p><p>假设将下一跳配置错误，错误地指向了R3的接口0。</p><p><img src="image/image_44.png" alt="image"></p><p>为了防止IP数据报在路由环路中永久兜圈，在IP数据报首部设有生存时间TTL字段。IP数据包进入路由器后，TTL字段的值减1.若TTL的值不等0，则路由器转发，否则丢弃。</p><h3 id="聚合不存在的网络"><a href="#聚合不存在的网络" class="headerlink" title="聚合不存在的网络"></a>聚合不存在的网络</h3><p><img src="image/image_45.png" alt="image"></p><p><img src="image/image_46.png" alt="image"></p><p><img src="image/image_47.png" alt="image"></p><p>当R2要转发IP数据报到不存在的网络时，进行查表转发。但对于这个不存在的网络，路由器R2应该不予转发，却错把它转发给了路由器R1。路由器R1查表转发，只能走默认路由。这样就产生了路由环路。</p><p><img src="image/image_48.png" alt="image"></p><p>解决：添加针对所聚合的、不存在的网络的黑洞路由。IP数据报进入后有去无回，即路由器丢了该IP数据报，当R2要转发IP数据报到不存在的网络时，进行查表转发，根据最长前缀匹配原则，将会选择该不存在网络的黑洞路由。</p><h3 id="网络故障"><a href="#网络故障" class="headerlink" title="网络故障"></a>网络故障</h3><p><img src="image/image_49.png" alt="image"></p><p><img src="image/image_50.png" alt="image"></p><p><img src="image/image_51.png" alt="image"></p><p>添加针对该直连网络的黑洞路由。这样可以解决网络故障导致的路由环路问题。假设一段时间后，之前的故障消失了，则R1又自动地得出了其接口0的直连网络的路由条目，并将之前人工配置的针对该直连网络的黑洞路由条目设置为失效状态。</p><p>假设R1再次检测到接口0所直连的网络出现了故障而不可达，则会自动在其路由表中删除该直连网络的路由条目，并将之前人工配置的针对该直连网络的黑洞路由条目设置为生效状态。</p><h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>路由选择分为：静态路由选择和动态路由选择。</p><p>静态路由选择：由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由。这种人工配置方式简单、开销小，但不能及时适应网络状态（流量、拓扑等）的变化。一般只在小规模网络中采用。</p><p>动态路由选择：路由器通过路由选择协议自动获取路由信息。比较复杂、开销比较大，能较好地适应网络状态的变化。适用于大规模网络。</p><h2 id="路由选择协议的主要特点"><a href="#路由选择协议的主要特点" class="headerlink" title="路由选择协议的主要特点"></a>路由选择协议的主要特点</h2><p>因特网所采用的路由选择协议的主要特点：自适应、分布式、分层次。</p><p>自适应：动态路由选择，能较好地适应网络状态的变化。</p><p>分布式：路由器之间交换路由信息。</p><p>分层式：将整个因特网划分为许多较小的自治系统AS。</p><h2 id="因特网采用分层次的路由选择协议"><a href="#因特网采用分层次的路由选择协议" class="headerlink" title="因特网采用分层次的路由选择协议"></a>因特网采用分层次的路由选择协议</h2><p><img src="image/image_52.png" alt="image"></p><p><img src="image/image_53.png" alt="image"></p><p>在一个自治系统内部使用的具体的内部网关协议与因特网中其他自治系统中选用何种内部网关协议无关。</p><h2 id="常见的路由选择协议"><a href="#常见的路由选择协议" class="headerlink" title="常见的路由选择协议"></a>常见的路由选择协议</h2><p><img src="image/image_54.png" alt="image"></p><h2 id="路由器的基本结构"><a href="#路由器的基本结构" class="headerlink" title="路由器的基本结构"></a>路由器的基本结构</h2><p>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是转发分组。整个路由器结构可划分为两大部分：路由选择部分和分组转发部分。</p><p><img src="image/image_55.png" alt="image"></p><p>路由选择部分的核心构件是路由选择处理机。它的任务是根据所使用的路由选择协议周期性地与其他路由器进行路由信息的交互来更新路由表。分组转发部分由三部分构成：交换结构、一组输入端口和一组输出端口。</p><p><img src="image/image_56.png" alt="image"></p><p>信号从某个输入端口进入路由器，物理层将信号转换成比特流，送交数据链路层处理。</p><p><img src="image/image_57.png" alt="image"></p><p>数据链路层从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理。</p><p><img src="image/image_58.png" alt="image"></p><p>如果送交网络层的分组是普通待转发的数据分组，则根据分组首部中的目的地址进行查表转发，若找不到匹配的转发条目，则丢弃该分组；否则，按照匹配条目中所指示的端口进行转发。</p><p><img src="image/image_59.png" alt="image"></p><p>网络层更新数据分组首部中某些字段的值，例如将会数据分组的生存时间减1。</p><p><img src="image/image_60.png" alt="image"></p><p>然后送交数据链路层进行封装成帧。</p><p><img src="image/image_61.png" alt="image"></p><p>送交物理层处理，物理层将帧看做比特流，将其变换成相应的电信号进行发送。</p><p><img src="image/image_62.png" alt="image"></p><p>如果送交网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交路由选择处理机。路由选择处理机根据分组的内容来更新自己的路由表。路由选择处理机除了处理收到路由报文外，还会周期性地给其他路由器发送自己所知道的路由信息。</p><blockquote><p>路由表一般仅包含从目的网络到下一跳的映射</p></blockquote><blockquote><p>路由表需要对网络拓扑变化的计算最优化</p></blockquote><blockquote><p>转发表是从路由表得出的</p></blockquote><blockquote><p>转发表的结构应当使查找过程最优化</p></blockquote><p><img src="image/image_63.png" alt="image"></p><p>路由器的各端口还应具有输入缓冲区和输出缓冲区。输入缓存区用来暂存新进入路由器但还来不及处理的分组。输出缓冲区用来暂存已经处理完毕但还来不及发送的分组。路由器的端口一般都具有输入和输出的功能。</p><h2 id="RIP的基本工作原理"><a href="#RIP的基本工作原理" class="headerlink" title="RIP的基本工作原理"></a>RIP的基本工作原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>路由信息协议RIP是内部网关协议IGP中最先得到广泛使用的协议之一，其相关标准文档为RFC1058.</p><p>RIP要求自治系统AS内的每一个路由器都要维护从它自己到AS内其他每一个网络的距离记录。这是一组距离，称为“距离向量D-V”。</p><p>RIP使用跳数作为度量来衡量到达目的网络的距离。</p><ul><li>路由器到直连网络的距离定义为1。</li><li>路由器到非直连网络的网络的距离定义为所经过的路由器加1.</li><li>允许一条路径最多只能包含15个路由器。距离等于16时相当于不可达。因此RIP只适用于小型互联网。</li></ul><p><img src="image/image_64.png" alt="image"></p><p>RIP认为好的路由就是“距离短”的路由，也就是所通过路由器数量最少的路由。</p><p><img src="image/image_65.png" alt="image"></p><p>当到达同一目的网络有多条“距离相等”的路由时，可以进行等价负载均衡。</p><p><img src="image/image_66.png" alt="image"></p><p>RIP包含以下三个要点：</p><ul><li>和谁交换信息 仅和相邻路由器交换信息</li><li>交换什么信息 自己的路由表</li><li>何时交换信息 周期性交换（如每30秒）</li></ul><h3 id="RIP的基本工作过程"><a href="#RIP的基本工作过程" class="headerlink" title="RIP的基本工作过程"></a>RIP的基本工作过程</h3><p><img src="image/image_67.png" alt="image"></p><p><img src="image/image_68.png" alt="image"></p><p><img src="image/image_69.png" alt="image"></p><ol><li>路由器刚开始工作时，只知道自己到直连网络的距离为1.</li><li>每个路由器仅和相邻路由器周期性地交换更新路由信息。</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下一跳地址，称为收敛。</li></ol><h3 id="RIP的路由条目更新规则"><a href="#RIP的路由条目更新规则" class="headerlink" title="RIP的路由条目更新规则"></a>RIP的路由条目更新规则</h3><p><img src="image/image_70.png" alt="image"></p><p><img src="image/image_71.png" alt="image"></p><p><img src="image/image_72.png" alt="image"></p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p><img src="image/image_73.png" alt="image"></p><h3 id="RIP存在“坏消息传播得慢”的问题"><a href="#RIP存在“坏消息传播得慢”的问题" class="headerlink" title="RIP存在“坏消息传播得慢”的问题"></a>RIP存在“坏消息传播得慢”的问题</h3><p>“坏消息传播得慢”又称为路由环路或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害。</p><p>限制最大路径为15（16表示不可达）</p><p>当路由表发生变化时就立即发送更新报文（即“触发更新”），而不仅是周期性发送</p><p>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即“水平分割”）</p><p><img src="image/image_74.png" alt="image"></p><p>假设R1到达其直连网络N1的链路出现了故障，当R1检测出该故障后，会将到达N1的路由条目中的距离修改为16，表示N1不可达，并等待RIP更新周期到时后发送该路由信息给R2.而此时R2的路由表中关于N1的路由条目仍然是先前通过RIP协议获取到的，也就是到达N1的距离为2，下一跳通过N1转发。假设R2的RIP更新周期先到时，而R1路由信息后到达R2.</p><p><img src="image/image_75.png" alt="image"></p><p>当R1收到R2的这条路由信息后，会被该谣言误导，认为可以通过R2到达N1，距离为3.并在自己的RIP更新周期到时后，将这条路由信息发送给R2.当R2收到R1的这条路由信息后，被该谣言误导，认为可以通过R1到达N1，距离改为4.并在自己的RIP更新周期到时后，将这条路由信息发送给R1……</p><p><img src="image/image_76.png" alt="image"></p><p><img src="image/image_77.png" alt="image"></p><p>最后，只有当R1和R2的路由表中，到达N1的路由条目中的距离都增加到16后，R1和R2才都知道N1不可达。在该过程中，R1和R2之间会出现路由环路，时间长达数分钟</p><h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><p><img src="image/image_78.png" alt="image"></p><p><img src="image/image_79.png" alt="image"></p><p><img src="image/image_80.png" alt="image"></p><h2 id="OSPF的基本工作原理"><a href="#OSPF的基本工作原理" class="headerlink" title="OSPF的基本工作原理"></a>OSPF的基本工作原理</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>开放最短路径优先OSPF，是为克服RIP的缺点在1989年开发出来的。</li><li>OSPF是基于链路状态的，而不像RIP那样是基于距离向量的。</li><li>OSPF采用SPF算法计算路由，从算法上保证了不会产生路由环路。</li><li>OSPF不限制网络规模，更新效率高，收敛速度快。</li><li>链路状态是指本路由器都和哪些路由相邻，以及相应链路的“代价”（费用、距离、时延、宽带等等）。</li></ul><p><img src="image/image_81.png" alt="image"></p><ul><li>OSPF相邻路由器之间通过交互问候（Hello）分组，建立和维护邻居关系。</li></ul><blockquote><p>Hello分组封装在IP数据报中，发往组播地址224.0.0.5；</p></blockquote><blockquote><p>发送周期为10秒；</p></blockquote><blockquote><p>40秒未收到来自邻居路由器的Hello分组，则认为该邻居路由器不可达。</p></blockquote><p><img src="image/image_82.png" alt="image"></p><p><img src="image/image_83.png" alt="image"></p><ul><li>使用OSPF每个路由器都会产生链路状态通告LSA。LSA包含以下内容：直连网络的链路状态信息、邻居路由器的链路状态信息。</li><li>LSA被封装在链路状态更新分组LSU中，采用洪泛法发送。</li></ul><p><img src="image/image_84.png" alt="image"></p><ul><li>使用OSPF的每个路由器都有一个链路状态数据库LSDB，用于存储LSA.</li><li>通过各路由器洪泛发送封装有自己LSA的LSU分组，各路由器的LSDB最终达到一致。</li></ul><p><img src="image/image_85.png" alt="image"></p><ul><li>使用OSPF的各路由器基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</li></ul><p><img src="image/image_86.png" alt="image"></p><ul><li>OSPF在多点接入网络中路由器邻居关系的建立</li></ul><p>为了减少所发送分组的数量，OSPF采用选举指定路由器DR和备用的指定路由器BDR的方法，所有的非DR/BDR只与DR/BDR建立邻居关系，非DR/BDR之间通过DR/BDR交换信息（若DR出现问题，则由BDR顶替DR）。</p><p>DR与BDR是通过各路由器之间交换一些选举参数，路由器优先级、路由器ID、接口IP地址等，根据选举规则选出DR和BDR，与交换机生成树协议选举根交换机类似。</p><p><img src="image/image_87.png" alt="image"></p><ul><li>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域。</li></ul><p>每个区域都有一个32比特的区域标识符，例如主干区域的标识符必须为0，也可表示成点分十进制形式的0.0.0.0。主干区域用于连通其他区域，其他区域的标识符不能为0且互不相同。每个区域的规模不应太大，一般所包含的路由器不应超过200个。</p><p>划分区域的好处：把利用洪泛法交换链路状态信息的范围，局限于每一个区域而不是整个自治系统，这样就减少了整个网络上的通信量。采用分层次划分区域的方法，虽然使交换信息种类增多了，同时也使OSPF协议更加复杂了，但这样却能使每一个区域内部交换路由信息的通信量大大减小，因而使OSPF协议能够用于规模很大的自治系统中。</p><p>如果路由器所有接口都在同一个区域内，则该路由器称为区域内路由器。LSA（链路状态通告）</p><p><img src="image/image_88.png" alt="image"></p><h3 id="OSPF五种分组类型"><a href="#OSPF五种分组类型" class="headerlink" title="OSPF五种分组类型"></a>OSPF五种分组类型</h3><ul><li>问候分组：用来发现和维护邻居路由器的可达性。</li><li>数据库描述分组：向邻居路由器给出自己的链路状态数据库中的所有链路状态项目摘要信息</li><li>链路状态请求分组：向邻居路由器请求发送某些链路状态项目得到详细信息。</li><li>链路状态更新分组：路由器使用这种分组将其链路状态进行洪泛发送，即用洪泛法对全网更新链路状态。</li><li>链路状态确认分组：这是对链路状态更新分组的确认分钟。</li></ul><h3 id="OSPF基本工作过程"><a href="#OSPF基本工作过程" class="headerlink" title="OSPF基本工作过程"></a>OSPF基本工作过程</h3><p><img src="image/image_89.png" alt="image"></p><p>相邻路由器之间周期性发送问候分组，以便建立和维护邻居关系。</p><p><img src="image/image_90.png" alt="image"></p><p>建立邻居关系后，给邻居路由器发送数据库描述分组（将自己的链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器）。例如，R1收到R2的数据库描述分组后，发现自己缺少其中的某些链路状态项目，于是就给R2发送链路状态请求分组。R2收到后，将R1所缺少的链路状态项目的详细信息，封装在链路状态更新分组中发送给R1.R1收到后，将这些所缺少的链路状态项目的详细信息，添加到自己的链路状态数据库中，并给R2发送链路状态确认分组（R2也可以向R1请求自己所缺少的链路状态项目的详细信息）。</p><p><img src="image/image_91.png" alt="image"></p><p>每30分钟或链路状态发送变化时，路由器都会发送链路状态更新分组。收到该分组的其他路由器将洪泛转发该分组，并给该路由器发回链路状态确认分组。</p><h2 id="BGP的基本工作原理"><a href="#BGP的基本工作原理" class="headerlink" title="BGP的基本工作原理"></a>BGP的基本工作原理</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li>因特网采用分层次的路由选择协议</li></ul><p><img src="image/image_92.png" alt="image"></p><ul><li>内部网关协议IGP（例如路由信息协议RIP或开房最短路径优先OSPF）</li></ul><p>设法使分组在一个自治系统内尽可能有效地从源网络传输到目的网络；无需考虑自治系统外部其他方面的策略。</p><ul><li>外部网关协议EGP（例如边界网关协议BGP）</li></ul><p>不同自治系统内，度量路由的“代价”（距离，宽带，费用等）可能不同。因此，对于自治系统之间的路由选择，使用“代价”作为度量来寻找最佳路由时不行的。</p><p>BGP只能是力求寻找一条能到达目的网络且比较好的路由，而并非要寻找一条最佳路由。 </p><p><img src="image/image_93.png" alt="image"></p><ul><li>在配置BGP时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”</li><li>不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接，端口号为179</li></ul><p>在此TCP连接上交换BGP报文以建立BGP会话；</p><p>利用BGP会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）；</p><p>使用TCP连接交换路由信息的两个BGP发言人，彼此称为对方的邻站或对等站。</p><ul><li>BGP发言人处理运行BGP外，还必须运行自己所在自治系统所使用的内部网关协议IGP，例如OSPF或RIP。</li><li>BGP发言人交换网络可达性的信息（要到达某个网络所要经过的一系列自治系统）</li><li>当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构、不存在回路的自治系统连通图。</li></ul><p><img src="image/image_94.png" alt="image"></p><ul><li>BGP适用于多级结构的因特网</li></ul><p><img src="image/image_95.png" alt="image"></p><h3 id="BGP-4的四种报文"><a href="#BGP-4的四种报文" class="headerlink" title="BGP-4的四种报文"></a>BGP-4的四种报文</h3><p>OPEN（打开）报文：用来与相邻的另一个BGP发言人建立关系，使通信初始化。</p><p>UPDATE（更新）报文：用来通告某一路由的信息，以及列出要撤销的多条路由。</p><p>KEEPALIVE（保活）报文：用来周期性地正式邻站的连通性。</p><p>NOTIFICATION（通知）报文：用来发送检测到的差错。</p><p>在BGP协议刚刚运行时，BGP的邻站交换整个BGP路由表。但以后只需要在发生变化时更新有变化的部分，这样做对节省网络宽带和减少路由器的处理开销都有好处。</p><h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><p><img src="image/image_96.png" alt="image"></p><p><img src="image/image_97.png" alt="image"></p><h1 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p><img src="image/image_98.png" alt="image"></p><ul><li>版本</li></ul><p>占4比特，表示IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为4（即IPv4）.</p><ul><li>首部长度</li></ul><p>占4比特，表示IP数据报首部的长度。该字段的取值以4字节为单位。最小十进制取值为5，表示IP数据报首部只有20字节固定部分；最大十进制取值为15，表示IP数据报首部包含20字节固定部分和最大40字节可变部分。</p><ul><li>可选字段</li></ul><p>长度从1字节到40个字节不等。用来支持排错、测量及安全等措施。可选字段增加了IP数据报的功能，但这同时也使得IP数据报的首部长度成为可变的。这就增加了每一个路由器处理IP数据报的开销。实际上可选字段很少被使用。</p><ul><li>填充字段</li></ul><p>确保首部长度为4字节的整数倍，使用全0进行填充。</p><ul><li>区分服务</li></ul><p>占8比特，用来获得更好的服务。该字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998年，因特网工程任务组IETF把这个字段改名为区分服务。利用该字段的不同数值可提供不同等级的服务质量。只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段。</p><ul><li>总长度</li></ul><p>占16比特，表示IP数据报的总长度（首部+数据载荷）。最大取值为十进制的65535，以字节为单位。</p><p>总长度与首部长度的联系：</p><p><img src="image/image_99.png" alt="image"></p><ul><li>标识</li></ul><p>占16比特，属于同一个数据报的各分片数据报应该具有相同的标识。IP软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段。</p><ul><li>标志</li></ul><p>占3比特，DF位：1标识不允许分片；0标识允许分片。MF位：1表示“后面还有分片”；0表示“这是最后一个分片”。保留位：必须为0。</p><ul><li>片偏移</li></ul><p>占13比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置还有多少单位。片偏移以8个字节为单位。</p><p>标识、标志、片偏移这三个字段共同用于IP数据报分片</p><p><img src="image/image_100.png" alt="image"></p><ul><li>生存时间TTL</li></ul><p>占8比特，最初以秒为单位，最大生存周期为255秒；路由器转发IP数据报时，将IP数据报首部中的该字段的值减去IP数据报在本路由器上所耗费的时间，若不为0就转发，否则丢弃。</p><p>现在以“跳数”为单位，路由器转发IP数据报时，将IP数据报首部中的该字段的值减1，若不为0就转发，否则就丢弃。</p><p>作用：防止IP数据报将在路由环路中兜圈。IP数据报每经过一个路由器，其生存时间的值被减1，直到TTL的值减少到0时被路由器丢弃。</p><ul><li>协议</li></ul><p>占8比特，指明IPv4数据报的数据部分是何种协议数据单元。常用的一些协议和相应的协议字段如下：</p><p><img src="image/image_101.png" alt="image"></p><p><img src="image/image_102.png" alt="image"></p><ul><li>首部检验和</li></ul><p>占16比特，用来检测首部在传输过程是否出现差错。比CRC检验码简单，称为因特网检验和。</p><p>IP数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段（生存时间、标志、片偏移等）的取值可能发生变化。</p><p>由于IP层本身并不提供可靠传输的服务，并且计算首部检验和是一项耗时的操作，因此在IPv6中，路由器不再计算首部检验和，从而更快转发IP数据报。</p><ul><li>源IP地址和目的IP地址</li></ul><p>各占32比特，用来填写发送该IP数据报的源主机和接收该IP数据报的目的主机的IP地址。</p><h2 id="IPv4数据报分片过程"><a href="#IPv4数据报分片过程" class="headerlink" title="IPv4数据报分片过程"></a>IPv4数据报分片过程</h2><p><img src="image/image_103.png" alt="image"></p><p><img src="image/image_104.png" alt="image"></p><h2 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h2><p><img src="image/image_105.png" alt="image"></p><p><img src="image/image_106.png" alt="image"></p><p><img src="image/image_107.png" alt="image"></p><p><img src="image/image_108.png" alt="image"></p><p><img src="image/image_109.png" alt="image"></p><p><img src="image/image_110.png" alt="image"></p><h1 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP。主机和路由器使用ICMP来发送差错报告报文和询问报文。ICMP报文被封装在IP数据报中发送。</p><h2 id="五种ICMP差错报告报文"><a href="#五种ICMP差错报告报文" class="headerlink" title="五种ICMP差错报告报文"></a>五种ICMP差错报告报文</h2><ul><li>终点不可达</li></ul><p>当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。具体可根据ICMP的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等种错误。</p><p><img src="image/image_111.png" alt="image"></p><ul><li>源点抑制</li></ul><p>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送抑制报文，使源点知道应该把数据报的发送速率放慢。</p><p><img src="image/image_112.png" alt="image"></p><p><img src="image/image_113.png" alt="image"></p><ul><li>时间超过</li></ul><p>路由器收到一个目的IP地址不是自己的IP数据报，会将其生存时间TTL字段的值减1.若结果不为0，则将该IP数据报转发出去；若结果为0，除丢弃该IP数据报外，还要向源点发送时间超过报文。</p><p><img src="image/image_114.png" alt="image"></p><p>另外，当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，也向源点发送时间超过报文。</p><ul><li>参数问题</li></ul><p>当路由器或器目的主机收到IP数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文。</p><p><img src="image/image_115.png" alt="image"></p><ul><li>改变路由（重定向）</li></ul><p>路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。</p><p><img src="image/image_116.png" alt="image"></p><p><strong>以下情况不应发送ICMP差错报文报告：</strong></p><ol><li>对ICMP的差错报告报文不再发送ICMP差错报告报文</li><li>对第一个分片的数据报片的所有后序数据报片都不发生ICMP差错报告报文</li><li>对具有多播地址的数据报都不发送ICMP差错报告报文</li><li>对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</li></ol><h2 id="常用的两种ICMP询问报文"><a href="#常用的两种ICMP询问报文" class="headerlink" title="常用的两种ICMP询问报文"></a>常用的两种ICMP询问报文</h2><ul><li>回送请求和回答</li></ul><p>ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达及了解其有关状态。</p><ul><li>时间戳请求和回答</li></ul><p>ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和实践。在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日期到当前时刻一共有多少秒。这种询问报文用来进行时钟同步和测量时间。</p><h2 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h2><ul><li>分组网间探测PING</li></ul><p>用来测试主机或路由器间的连通性；应用层直接使用网际层的ICMP（没有通过运输层的TCP或UDP）；使用ICMP回送请求和回答报文。</p><ul><li>跟踪路由</li></ul><p>用来测试IP数据报从源主机到达目的主机要经过哪些路由器。</p><p><img src="image/image_117.png" alt="image"></p><p><strong>H1如何知道到达H2要经过哪些路由器？</strong></p><p><img src="image/image_118.png" alt="image"></p><p><img src="image/image_119.png" alt="image"></p><p>H1给H2发送ICMP回送请求报文，该报文被封装在IP数据报中。IP数据报首部中生存时间字段TTL的值被设置为1。该IP数据报到达R1后，其生存时间减1结果为0，R1丢弃该数据报并向发送该数据报的源主机H1，发送ICMP差错报告报文，类型为时间超过。这样H1就知道了到达H2的路径的第一个路由器。</p><p><img src="image/image_120.png" alt="image"></p><p><img src="image/image_121.png" alt="image"></p><p><img src="image/image_122.png" alt="image"></p><p><img src="image/image_123.png" alt="image"></p><p><img src="image/image_124.png" alt="image"></p><h1 id="虚拟专用网与网络地址转换NAT"><a href="#虚拟专用网与网络地址转换NAT" class="headerlink" title="虚拟专用网与网络地址转换NAT"></a>虚拟专用网与网络地址转换NAT</h1><h2 id="虚拟专用网"><a href="#虚拟专用网" class="headerlink" title="虚拟专用网"></a>虚拟专用网</h2><p>利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。由于IPv4地址的紧缺，一个机构能够申请到的IPv4地址数量往往远小于本机构所拥有的主机数量。因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公用地址。</p><p><img src="image/image_125.png" alt="image"></p><p>路由器R1收到该数据报后，发现其目的网络必须通过因特网才能到达，就将该内部IP数据报进行加密。然后重新添加数据报的首部，封装成为在因特网上发送的外部数据报。其首部中源地址字段值为路由器R1的全球地址，目的地之为路由器R2的全球地址。</p><p>路由器R2收到该数据报后，去掉其首部，将其数据部分进行解密，恢复出原来内部IP数据报。这样就可以从其首部提取出源地址和目的地址。根据目的地址，将该内部IP数据报发送给相应的主机。</p><p><img src="image/image_126.png" alt="image"></p><p>两个专用网内的主机间发送的数据报，是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样。数据报在因特网中可能要经过多个网络和路由器。但从逻辑上看，R1和R2之间好像是一条直通的点对点链路，因此称为IP隧道技术。</p><p>本例子为同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN。有时一个机构的VPN需要有某些外部机构（通常是合作伙伴）参加进来。这样的VPN称为外联网VPN。在外地工作的员工需要访问公司内部的专用网络时，只要在任何地方接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为远程接入VPN。</p><h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><p>虽然因特网采用了无分类编址方式来减缓IPv4地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4地址空间即将面临耗尽的危险仍然没有被解除。</p><p>1994年提出了一种网络地址转换NAT的方法再次缓解了IPv4地址空间即将耗尽的问题。NAT能使大量使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。ju</p><p><strong>举例</strong></p><p><img src="image/image_127.png" alt="image"></p><p><strong>使用私有地址的主机如何与因特网上使用全球IP地址的主机进行通信呢？</strong></p><p>这需要在专用网络连接到因特网的路由器上，安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换成全球IP地址。</p><p><img src="image/image_128.png" alt="image"></p><p>假设使用私有地址的该主机，要给因特网上使用全球IP地址的另一台主机发送IP数据报。NAT路由器从自己的全球IP地址池中，为该主机分配一个临时的全球IP地址，然后将私有地址与全球地址的对应关系记录在NAT转换表中，之后就可以转发该IP数据报了。</p><p><img src="image/image_129.png" alt="image"></p><p>因特网上的这台主机给源主机发回数据报，NAT路由器收到该IP数据报后，在NAT转换表中进行查找。</p><p><strong>该转换方法存在一个问题：</strong>如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够同时和因特网上的主机通信。</p><p><strong>解决方法：</strong>由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。这样，用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种端口号和IP地址一起进行转换的技术叫作网络地址与端口号转换NAPT。</p><p><img src="image/image_130.png" alt="image"></p><p><img src="image/image_131.png" alt="image"></p><p>另外，由于NAT对外网屏蔽了内网主机的网络地址，能为内网主机提供一定的安全保护。</p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.icourse163.org/course/HNKJ-1461816178">计算机网络_湖南科技大学_中国大学MOOC(慕课) (icourse163.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;网络层的主要任务是实现网络互连，进而实现数据报在各网络之间的传输。因特网是目前全世界用户数量最多的互联网，它使用TCP/IP协议栈。由于TCP/IP协议栈的网络层使用网际协议IP，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为网际层。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络层" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络层" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://github.com/LittleWills/GameWill.github.io.git/2021/12/12/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://github.com/LittleWills/GameWill.github.io.git/2021/12/12/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-12-12T10:04:10.000Z</published>
    <updated>2022-04-30T16:25:51.369Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>链路就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。实现通信协议的硬件和软件加到链路上，就构成了数据链路。数据链路层以帧尾单位传输和处理数据。封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p></blockquote><span id="more"></span><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="image/image.png" alt="image"></p><p>在大多数据情况下，我们可以只关心数据链路层，而不考虑网络体系结构的其他各层。也可以想象，数据包只在数据链路层从左向右沿水平方向传送。从数据链路层来看，主机H1到H2的通信，可以看成是在4段不同链路上的通信组成的。</p><p><img src="image/image_1.png" alt="image"></p><ul><li>链路：就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</li><li>数据链路：是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。</li><li>数据链路层以帧尾单位传输和处理数据。</li></ul><h1 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h1><p><img src="image/image_2.png" alt="image"></p><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p><p><img src="image/image_3.png" alt="image"></p><p>帧头和帧尾中包含有重要的控制信息；帧头和帧尾的作用之一是<strong>帧定界</strong>，接收方的数据链路层可以从物理层交付的比特流中提取一个个的帧。</p><p><img src="image/image_4.png" alt="image"></p><p>以太网V2的MAC帧在帧头和帧尾中没有包含帧定界标志，这种，物理层会在MAC帧前面添加8字节前导码，然后再将比特流转换成电信号发送。前7字节为前同步码，作用是使接收方的时钟同步。1字节为帧开始定界符，表明后面跟着的就是MAC帧。</p><p><img src="image/image_5.png" alt="image"></p><p>以太网还规定了帧间间隔时间为96比特的发送时间。因此，MAC帧并不需要帧结束定界符。</p><p><img src="image/image_6.png" alt="image"></p><p><img src="image/image_7.png" alt="image"></p><p>透明传输是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。在发送帧之前，对帧的数据部分进行扫描，每出现一个帧定界符，就在其前面插入一个转义字符。接收方数据链路层在物理层交付的比特流中提取帧，遇到第一个帧定界符是，认为是帧的开始，当遇到转义字符时，其后面1字节内容虽然与帧定界符相同，但它是数据而不是定界符，剔除转义字符后将其后面的内容作为数据继续提取，最后提取帧定界符时，表明这是帧的结束。这样可以避免接收方对帧是否结束的误判。</p><p><img src="image/image_8.png" alt="image"></p><p>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输。面向比特的物理链路使用比特填充分方法实现透明传输。假如帧的数据部分出现了两个帧定界标志，但它们实际上是数据，而不是帧定界。在发送前，可以采用0比特填充法，对数据部分进行扫描，每5个连续的比特1后面就插入1个比特0。这样就确保了帧定界在整个帧的唯一性，也就可以实现透明传输。接收方的数据链路层，从物理层交付的比特流中提取帧时，将帧的数据部分中的每5个连续的比特1后面的那个比特0提出即可。</p><p><img src="image/image_9.png" alt="image"></p><p><img src="image/image_10.png" alt="image"></p><h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><ul><li>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：1可能会变成0，而0也可能变成1。这称为比特差错。</li><li>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER。</li><li>使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</li></ul><p><img src="image/image_11.png" alt="image"></p><p>帧检验序列FCS字段，自作用是让接受方的数据链路层，检查帧在传输过程中是否产生了误码。</p><h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><ul><li>在待发送的数据后面添加1位奇偶校验位，使整个数据（包括所添加的校验位在内）中“1”的个数为奇数（奇校验）或偶数（偶校验）。</li></ul><p><img src="image/image_12.png" alt="image"></p><ul><li>如果有奇数个位发生误码，则奇偶性发生变化，可以检查误码；如果有偶数个位发生误码。则奇偶不发生改变，不能检查出误码（漏检）。漏检率较高</li></ul><h2 id="循环冗余检验CRC"><a href="#循环冗余检验CRC" class="headerlink" title="循环冗余检验CRC"></a>循环冗余检验CRC</h2><ul><li>收发双方约定好一个生成多项式G（x）；</li><li>发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加到待传输数据的后面一起传输；</li><li>接收方通过生产多项式来计算收到的数据是否产生了误码；</li></ul><p><img src="image/image_13.png" alt="image"></p><p><img src="image/image_14.png" alt="image"></p><p><img src="image/image_15.png" alt="image"></p><p><img src="image/image_16.png" alt="image"></p><p>检错码只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此无法纠正错误。要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。循环冗余校验CRC漏检率地，虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层。</p><h1 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h1><ul><li>使用差错检测技术（例如循环冗余校验CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特错误）。</li><li>数据链路层向上层提供的服务类型：1. 不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做；2. 可靠传输服务：想办法实现发送端发送什么，接收端就收到什么。</li><li>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由上层处理。</li><li>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</li><li>比特差错只是传输差错中的一种，从整个计算机网络体系结构看，传输差错还包括分组丢失、分组失序以及分组重复。这些传输差错一般不会出现在数据链路层，而会出现在上层。</li><li>可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输。</li></ul><p><img src="image/image_17.png" alt="image"></p><h2 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h2><p>自动请求重传ARQ</p><p><img src="image/image_18.png" alt="image"></p><p>收发双方基于互联网进行通信，而不是局限在一条点对点的数据链路。发送方给接收方发送数据分组。接收方收到后对其进行差错检测，若没有误码，则接受该数据分组，并给发送方发送确认分组，简称ACK。发送方收到对所发送数据分组的确认分组后，才能发送下一个数据分组。假设数据分组在传输过程中出现了误码，接收方收到后对其进行差错检测，发现误码，则丢弃该数据分组，并给发送方发送否认分组，简称NAK。发送方收到对所发送数据分组的否认分组后，就知道了之前自己所发送的数据分组，出现了差错而被接收方拒绝，于是立刻重传该数据分组。因此，发送方每发送完一个数据分组后，并不能立刻将数据分组从缓存中删除，只有在收到针对该数据分组的确认分组后，才能将其从缓存中删除。这样就实现了发送方发送什么，接收方最终都能收到什么。实现了可靠传输。</p><p><img src="image/image_19.png" alt="image"></p><p>发送方给接收方发送数据分组，该数据分组在传输过程中丢失了。（对于数据链路层点对点信道，不太容易出现这种情况；对于多个网络通过多个路由器互连的复杂互联网环境而言，这种情况是会经常出现的。）发送方超时重传之前所发送的数据分组。接收方正确接收重传的数据分组后，给发送方发送确认分组，发送方收到确认分组后，发送下一个数据分组。接收方正确接收该数据分组后，给发送方发送确认分组。</p><blockquote><p>接收方收不到数据分组，就不会发送ACK或NAK。如果不采取其他措施，发送方就会一直处于等待接收方ACK或NAK的状态。为了解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间而发送方仍收不到接收方的任何ACK或NAK，则重传原来的数据分组，称为超时重传。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。</p></blockquote><p><img src="image/image_20.png" alt="image"></p><p>发送方发送一个数据分组，接收方正确接收该数据分组后，给发送方发送确认分组。但该确认分组在传输过程中丢失了。这必然会造成发送方对之前所发送数据分组的超时重传。假设重传数据分组正确到达了接收方。根据数据分组的序号，接收方就可以判断出该数据分组是否是重复的。接收方丢弃重复的数据分组，并给发送方发送针对该数据分组的确认分组，以免发送方对该数据分组的再次超时重传。</p><blockquote><p>为避免分组重复这种传输错误，必须给每个分组带上序号。对于停止-等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号。即序号0和1。</p></blockquote><p><img src="image/image_21.png" alt="image"></p><p>发送方发送0号数据分组，接收方正确接收后给发送方发送确认分组。由于某些原因，该确认分组迟到了，这必然会导致发送方对0号数据分组的超时重传。在重传的0号数据分组的传输过程中，发送方收到了迟到的确认分组，于是发送1号数据分组。接收方收到重传的0号数据分组后，发现这是一个重复的数据分组，将其丢弃。并针对该数据分组，给发送方发送确认分组，以免发送方再次超时重传该数据分组。</p><p>如果对确认分组也进行编号，就可以使发送方避免这种误判。发送方通过确认分组的序号，知道这是一个重复的确认分组，忽略即可，接收方正确接收1号数据分组后，给发送方发送针对该数据分组的确认分组，其序号为1。发送方收到该确认分组后，发送下一个数据分组，序号为0（该数据分组与之前序号为0的数据分组不相同）。</p><p>对于数据链路层点对点信道，往返时间比较固定，不会出现确认迟到的情况。因此只在数据链路层实现停止-等待协议，可以不用给确认分组编号。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。</li><li>为了接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1.</li><li>为了让发送方能够判断所收到的ACK分组是否重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。</li><li>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间”。在数据链路层点对点的往返时间比较确定，重传时间比较好设定。然而在运输层，由于端到端往返时间非常不稳定，设置合适的重传时间有时并不容易。</li></ul><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p><img src="image/image_22.png" alt="image"></p><p><img src="image/image_23.png" alt="image"></p><h2 id="回退N帧协议"><a href="#回退N帧协议" class="headerlink" title="回退N帧协议"></a>回退N帧协议</h2><p><img src="image/image_24.png" alt="image"></p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数。</p><p><img src="image/image_25.png" alt="image"></p><p>发送方维持一个发送窗口，序号落在发送窗口内的数据分组可被连续发送，而不必等收到接收方的相应确认分组后再发送。</p><h3 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h3><p><img src="image/image_26.png" alt="image"></p><p>发送方将序号落在发送窗口内的0至4号数据分组，依次连续发送出去，经过互联网的传输正确到达接收方，没有出现乱序和误码。接收方按序接收，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组。0至4确认分组经过互联网的传输正确到达了发送方，发送方每接收到一个，发送窗口就向前滑动一个位置，这样就有新的序号落入了发送窗口。发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理。</p><h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><p><img src="image/image_27.png" alt="image"></p><p>发送方将序号落在发送窗口内的0至4号数据分组，依次连续发送出去，经过互联网的传输正确到达接收方。接收方按序接收，当接收完0号和1号数据分组后，给发送方发送了一个累计确认ACK1。当接收完2至4号数据分组后，给发送方发送一个累积确认ACK4。假设ACK1在传输过程中丢失了，而ACK4正确到达了发送方。发送方接收ACK4后，知道序号为4及之前的数据分组已被接收方正确接收。于是将发送窗口向前滑动5个位置，这样就有新的序号落入了发送窗口。发送方可以将收到确认的数据分组从缓存中删除了，接收方可以择机将已接收的数据分组交付上层处理。</p><h3 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h3><p><img src="image/image_28.png" alt="image"></p><p><img src="image/image_29.png" alt="image"></p><p>假设传输过程中受到了干扰，其中五号数据分组出现了误码。接收方通过数据分组中的检错码发现了错误，于是丢弃该数据分组。而后序到达的数据分组序号，与接收窗口中的序号不匹配。接收方同样不能接受他们，将它们丢弃并对之前按序接收的最后一个数据分组进行确认，发送ACK4。每丢弃一个数据分组，就发送一个ACK4。4个ACK4经过互联网的传输到达了接收方，发送方之前接收过ACK4，当重复接收时，就知道了之前所发送的数据分组出现了差错，可以不等超时计时器就立刻开始重传。</p><blockquote><p>尽管序号为6，7，0，1的数据分组正确到达接收方，但由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受，发送方还要重传这些数据分组，即回退N帧。可见，当通信线路质量不好时，回退N帧协议的信道利用率并不比停止-等待协议高。</p></blockquote><p><strong>若发送窗口尺寸超过取值范围，会出现什么情况？</strong></p><p><img src="image/image_30.png" alt="image"></p><p>发送方将序号落在发送窗口内的0至7号8个数据三个数据分组，依次连续发送，，经过互联网的传输正确到达接收方。接收方按序接收，给发送方发回累计确认ACK7。假设ACK7在传输过程中丢失了，发送方超时重传，重传的0至7号数据分组到达接收方。接收方根据当前接收窗口内的序号，会对这8个数据分组按序接收，但是之前已接收，接收方无法分辨新、旧数据分组，会产生分组重复传输差错。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="image/image_31.png" alt="image"></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><img src="image/image_32.png" alt="image"></p><h2 id="选择重传协议"><a href="#选择重传协议" class="headerlink" title="选择重传协议"></a>选择重传协议</h2><ul><li>回退N帧协议的接收窗口尺寸只能等于1，因此接收方只能按序接收正确到达的数据分组。</li><li>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃（尽管它们无乱序和误码）。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</li><li>为了提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸不应再等于1（大于1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层，即选择重传协议。</li><li>选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收的数据分组进行逐一确认。</li></ul><p><img src="image/image_33.png" alt="image"></p><p><img src="image/image_34.png" alt="image"></p><p>发送方将序号0至3数据分组依次连续发送出去，经过互联网的传输正确到达接收方。其中2号数据分组丢失了，只要序号落入接收窗口内且无误码的数据分组，接收方都会接收。接收方接收0号和1号数据分组，并发送0号和1号确认分组，接收窗口向前滑动两个位置。这样就有4和5这两个新的序号落入接收窗口。接收方接收3号数据分组，并发送3号确认分组，但接收窗口不能向前滑动，因为3号数据分组是未按序到达的数据分组。</p><p><img src="image/image_35.png" alt="image"></p><p>这些确认分组经过互联网的传输陆续到达发送方。发送方每按序收到一个确认分组，发送窗口就向前滑动一个位置。发送方接收0号和1号确认分组，发送窗口向前滑动两个位置。4和5这两个新的序号落入发送窗口，发送方将序号落入发送窗口的4号和5号数据分组发送出去。发送方可以将已经收到确认的0号和1号数据分组，从发送缓存中删除。接收方可择机将已按序接收的0号和1号数据分组交付上层处理，发送方接收3至5号数据分组，但发送窗口不能向前滑动，因为这是一个未按序到达的确认分组，发送方还未收到它之前的2号确认分组，同时需要记录4号和5号数据分组已收到确认，这样它们就不会超时重发。</p><p><img src="image/image_36.png" alt="image"></p><p>发送方重传的2号数据分组到达接收方，接收方接受该数据分组，并发送2号确认分组，接收窗口可以向前滑动4个位置。2号确认分组经过互联网传输到达发送方，发送方接收该确认分组，发送窗口可以向前滑动4个位置。</p><p><img src="image/image_37.png" alt="image"></p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="image/image_38.png" alt="image"></p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p><img src="image/image_39.png" alt="image"></p><h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><p>点对点PPP是目前使用最广泛的点对点数据链路层协议。</p><p><img src="image/image_40.png" alt="image"></p><p>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</p><ul><li>对各种协议数据报的封装方法（封装成帧）</li><li>链路控制协议LCP（用于建立、配置以及测试数据链路的连接）</li><li>一套网络控制协议NCPs（其中的每一个协议支持不同的网络层协议）</li></ul><p><img src="image/image_41.png" alt="image"></p><h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p><img src="image/image_42.png" alt="image"></p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><h3 id="面向字节的异步链路采用插入转义字符的字节填充法"><a href="#面向字节的异步链路采用插入转义字符的字节填充法" class="headerlink" title="面向字节的异步链路采用插入转义字符的字节填充法"></a>面向字节的异步链路采用插入转义字符的字节填充法</h3><p><img src="image/image_43.png" alt="image"></p><h3 id="面向比特的同步链路采用插入比特0的比特填充法"><a href="#面向比特的同步链路采用插入比特0的比特填充法" class="headerlink" title="面向比特的同步链路采用插入比特0的比特填充法"></a>面向比特的同步链路采用插入比特0的比特填充法</h3><p><img src="image/image_44.png" alt="image"></p><h2 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h2><p><img src="image/image_45.png" alt="image"></p><h2 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h2><p>拨号接入为例</p><p><img src="image/image_46.png" alt="image"></p><h1 id="媒体接入控制"><a href="#媒体接入控制" class="headerlink" title="媒体接入控制"></a>媒体接入控制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="image/image_47.png" alt="image"></p><p>有多台主机连接到这根同轴电缆上，它们共享这根传输媒体，形成了一个总线型局域网。各主机竞争使用总线，随机地在信道上发送数据。</p><p><img src="image/image_48.png" alt="image"></p><p>如果恰巧有两个或更多的站点，在同一时刻发送数据，信号在共享媒体上就要产生碰撞，即发生冲突，使得这些站点的发送都失败。</p><ul><li>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制MAC。</li></ul><p><img src="image/image_49.png" alt="image"></p><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</p><h2 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h2><h3 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h3><ul><li>复用是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。</li><li>当网络中传输媒体的传输容量大于多条单一信道传输的总通量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</li></ul><p><img src="image/image_50.png" alt="image"></p><h4 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h4><p><img src="image/image_51.png" alt="image"></p><p>将传输线路的频带资源划分成多个子频带，形成多个子信道，各子信道之间需要留出隔离频带，以免造成子信道间的干扰。当多路信号输入一个多路复用器时，这个复用器将每一路信号调制到不同频率的载波上。接收端由相应的分用器通过滤波将各路信号分开，将合成的复用信号恢复成原始的多路信号。</p><h4 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h4><p><img src="image/image_52.png" alt="image"></p><p>将时间划分时隙，时分复用技术将传输线路的带宽资源，按时隙轮流分配给不同的用户，每对用户只在所分配的时隙里使用线路传输数据。时分复用技术将时间划分成了一段段等长的时分复用帧。每一个时分复用的用户在每一个时分复用帧中占用固定序号的时隙。</p><h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><p><img src="image/image_53.png" alt="image"></p><h4 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h4><p>码分复用CDM是另一种共享信道的方法。由于该技术主要用于多址接入，常用的名词是码分多址CDMA。</p><p>频分复用FDM和时分复用TDM同样可用于多址接入，相应名词是频分多址FDMA和时分多址TDMA。</p><p>在不严格区分复用与多址的概念，可简单理解为：</p><ul><li>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分。</li><li>多址（多点接入）处理的是动态分配信道给用户。用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户应用中，多址是不需要的（无线广播或电视广播站）。</li><li>某种程度上，FDMA、TDMA、CDMA可以分别看成FDM、TDM、CDM的应用。</li></ul><p>与FDM和TDM不同，CDM的每一个用户可以在同样的时间使用同样的频带进行通信，由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p><p><strong>举例</strong></p><p>在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片。通常m的值是64或128。简单起见，假设m为8。</p><p>直接序列扩频：使用CDMA的每一个站被指派一个唯一的mbit码片序列。一个站如果要发送比特1，则发送它自己的mbit码片序列；一个站如果要发送比特0，则发送它自己的mbit码片序列的二进制反码。</p><p><img src="image/image_54.png" alt="image"></p><p>码片序列的挑选原则：</p><ol><li>分配给每个站的码片序列必须各不相同，实际常用伪随机码系列。</li><li>分配给每个站的码片序列必须相互正交（规格化积为0）.</li></ol><p><img src="image/image_55.png" alt="image"></p><p><img src="image/image_56.png" alt="image"></p><p><img src="image/image_57.png" alt="image"></p><p><img src="image/image_58.png" alt="image"></p><p><img src="image/image_59.png" alt="image"></p><h2 id="随机接入"><a href="#随机接入" class="headerlink" title="随机接入"></a>随机接入</h2><p><img src="image/image_60.png" alt="image"></p><h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p>载波监听多址接入/碰撞检测（总线局域网使用的协议）</p><p>CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中。现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议。</p><p><img src="image/image_61.png" alt="image"></p><h4 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h4><p>多个主机连接到一根总线上，各主机随机发送帧。</p><h4 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h4><p><img src="image/image_62.png" alt="image"></p><p>假设主机C发送帧，首先进行载波监听，检测到总线空闲96比特时间后，就可以发送帧了。假设主机C使用总线发送帧的过程中，主机B也要发送帧，主机B进行载波监听，发现总线忙，于是持续检测总线，一旦发现总线空闲96比特时间，则立即发送帧。</p><h4 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h4><p><img src="image/image_63.png" alt="image"></p><p>同时也要检测碰撞，如果没检测到碰撞，则可继续发送帧的剩余部分。假设在主机B发送帧的过程中，主机C发送帧，主机C进行载波监听，发现总线空闲96比特时间后立即发送帧，这必然会产生碰撞。产生碰撞时刻，主机B和主机C边发送边检测碰撞但都检测不到碰撞。碰撞信号沿总线传播，主机C会比主机B更早检测到碰撞并停止发送，退避一段随机时间后，重新再发送之前所发送的帧。</p><h4 id="争用期（碰撞窗口）"><a href="#争用期（碰撞窗口）" class="headerlink" title="争用期（碰撞窗口）"></a>争用期（碰撞窗口）</h4><p><img src="image/image_64.png" alt="image"></p><h4 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h4><p><img src="image/image_65.png" alt="image"></p><h4 id="最大帧长"><a href="#最大帧长" class="headerlink" title="最大帧长"></a>最大帧长</h4><p><img src="image/image_66.png" alt="image"></p><h4 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h4><p><img src="image/image_67.png" alt="image"></p><h4 id="信道利用率-1"><a href="#信道利用率-1" class="headerlink" title="信道利用率"></a>信道利用率</h4><p><img src="image/image_68.png" alt="image"></p><h4 id="帧发送流程"><a href="#帧发送流程" class="headerlink" title="帧发送流程"></a>帧发送流程</h4><p><img src="image/image_69.png" alt="image"></p><h4 id="帧接收流程"><a href="#帧接收流程" class="headerlink" title="帧接收流程"></a>帧接收流程</h4><p><img src="image/image_70.png" alt="image"></p><h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><p><img src="image/image_71.png" alt="image"></p><p><img src="image/image_72.png" alt="image"></p><p><img src="image/image_73.png" alt="image"></p><p><img src="image/image_74.png" alt="image"></p><h3 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a>CSMA/CA协议</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>载波监听多址接入/碰撞避免（无线局域网使用的协议）</p><p><strong>既然CSMA/CD协议已经成功地应用于使用广播信道的有线局域网，那么同样使用广播信道的无线局域网能不能使用CSMA/CD协议呢？</strong></p><p>在无线局域网中，仍然可以使用载波监听多址接入CSMA，即在发送帧之前先对传输媒体进行载波监听。若发现有其他站在发送帧，就推迟发送以免发生碰撞。</p><p>在无线局域网中，不能使用碰撞检测CD的原因：</p><ul><li>由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高。</li><li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），进行碰撞检测的意义不大。</li></ul><p><img src="image/image_75.png" alt="image"></p><p>无线站点，这种未能检测出信道上其他站点信号的问题叫做隐蔽站问题。同样使用广播信道的有线局域网，不存在该问题，总线上某个主机发送的信号，最多经过一个总线端到端传播时延，就会被总线上的各主机接收到。而总线上产生的碰撞信号，最多经过一个总线端到端往返传播时延，也会传遍总线。</p><p><strong>解决方式</strong></p><ul><li>802.11无线局域网使用CSMA/CA协议，在CSMA的基础上增加了一个碰撞避免CA功能，而不再实现碰撞检测功能。</li><li>由于不可能避免所有的碰撞，并且无线信道误码率较高，802.11标准还使用了数据链路层确认机制（停止-等待协议）来保证数据正确接收。</li><li>802.11的MAC层标准定义了两种不同的媒体接入控制方式：1. 分布式协调功能DCF。在DCF方式下，没有中心控制站点，每个站点使用CSMA/CA协议通过争用信道来获取发送权，这是802.11定义的默认方式。2. 点协调功能PCF。 PCF方式使用集中控制的接入算法（一般在接入点API实现集中控制），是802.11定义的可选方式，在实际中较少使用。</li></ul><h4 id="帧间间隔IFS"><a href="#帧间间隔IFS" class="headerlink" title="帧间间隔IFS"></a>帧间间隔IFS</h4><ul><li>802.11标准规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔IFS。</li><li>帧间间隔的长短取决于该站点要发送的帧的类型：1. 高级优先级帧需要等待的时间较短，因此可优先获得发送权；2. 低优先级帧需要等待的时间较长。若某个站的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送了。这样就减少了发送碰撞的机会。</li><li>常用得到两种帧间间隔：1. 短帧间间隔SIFS（28微秒），是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应能够在这段时间内从发送方式切换到接收方式。使用SIFS的帧类型有ACK帧，CTS帧，由过长的MAC帧分片后的数据帧、以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧。2. DCF帧间间隔DIFS（128微秒），它比短帧间间隔SIFS要长得多，在DCF方式中用来发送数据帧和管理帧。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="image/image_76.png" alt="image"></p><p>无线信道空闲，源站有数据帧要发送，当源站检测到信道空闲，则在等待帧间间隔DIFS后发送该数据帧。目的站若正确收到该数据帧，则经过帧间间隔SIFS后，向源站发送确认帧ACK。（若源站在规定时间内没有收到确认帧ACK，由重传计时器控制这段时间，就必须重传该数据帧，直到收到确认为止，或者经过若干次的重传失败后放弃发送）。</p><p>问题一：源站为什么在检测到信道空闲还要再等待一段时间DIFS？</p><p>答：就是考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送。</p><p>问题二：目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</p><p>答：SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。</p><p><img src="image/image_77.png" alt="image"></p><p>在源站和目的站的一次对话过程中，无线信道处于忙状态。若无线信道处于忙状态时，其他无线站点要发送数据，则必须退避。当信道从忙状态转换到空闲状态，并经过帧间间隔DIFS后，其他要发送数据的无线站点，需要退避一段随机时间后才能发送。</p><p>问题一：信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</p><p>答：防止多个站点同时发送数据产生碰撞。</p><p>当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法。</p><p>必须使用退避算法的情况：1.  在发送数据帧之前检测到信道处于忙状态时；2.  在每一次重传一个数据帧时；3.  在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）。</p><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><p><img src="image/image_78.png" alt="image"></p><p><img src="image/image_79.png" alt="image"></p><p>假设A正在占用无线信道发送帧，在A的发送过程中，B、C、D也要发送帧，于是进行载波监听，发现信道忙，需要退避。根据退避算法选择出一个随机的退避时间，并在每个时隙对信道进行一次检测，当检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器开始倒计时。</p><p><img src="image/image_80.png" alt="image"></p><p>假设C的退避时间最短，当C的退避计时器到时后，C立即开始发送帧。此时信道由空闲状态转换为忙状态，当B和D检测到信道忙后，就冻结各自剩余的退避时间。</p><p><img src="image/image_81.png" alt="image"></p><p>假设在C占用无线信道发送帧的过程中，E也要发送帧，于是进行载波监听，发现信道忙，需要退避。根据退避算法选择出一个随机的退避时间，并在每个时隙对信道进行一次检测，当检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器开始倒计时。当B和D检测到信道由忙状态转为空闲状态，且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。D的退避计时器会首先到时，D立即开始发送帧。</p><p><img src="image/image_82.png" alt="image"></p><p>此时信道由空闲状态转换为忙状态，当B和E检测到信道忙后，就冻结各自剩余的退避时间。当D发送完帧后，信道将转为空闲状态。当B和E检测到信道由忙状态转为空闲状态且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。E的退避计时器会首先到时，E立即开始发送帧。此时信道由空闲状态转换为忙状态，当B检测到信道忙后，就冻结自己的剩余退避时间。</p><p><img src="image/image_83.png" alt="image"></p><p>当E发送完帧后，信道将转为空闲状态。当B检测到信道由忙状态转换为空闲状态，且经过帧间间隔DIFS后，退避计时器重新开始从上次冻结的退避剩余时间开始倒计时。当B的退避计时器到时后，B立即开始发送帧。若B发送完这一帧后还有帧要发送，则在检测到信道空闲且经过帧间间隔DIFS后，还必须再退避一段随机时间后才能发送。</p><h4 id="信道预约和虚拟载波监听"><a href="#信道预约和虚拟载波监听" class="headerlink" title="信道预约和虚拟载波监听"></a>信道预约和虚拟载波监听</h4><p><img src="image/image_84.png" alt="image"></p><ul><li>为了尽可能减少碰撞的概率和降低碰撞的影响，802.11标准允许要发送数据的站点对信道进行预约。</li></ul><ol><li>源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS，它包括源地址、目的地址以及这次通信（包括相应的确认帧）所需的持续时间。</li><li>若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS，它也包括这次通信所需的持续时间（从RTS帧中将此持续时间复制到CTS帧中）。</li><li>源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧。</li><li>若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK。</li></ol><ul><li>除源站和目的站以外的其他各站，在收到CTS帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</li><li>如果RTS帧发生碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧。</li><li>由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销很小。而对于一般的数据帧，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费时间就很多，因此用很小的代价对信道进行预约往往是值得的。</li></ul><blockquote><p>802.11标准规定了3种情况供用户选择：1. 使用RTS帧和CTS帧。 2. 不使用RTS帧和CTS帧。3. 只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧。</p></blockquote><ul><li>除RTS帧和CTS帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为802.11的虚拟载波监听机制。</li><li>由于利用虚拟载波监听机制，站点只要监听到RTS帧、CTS帧或数据帧中任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题。</li></ul><p><img src="image/image_85.png" alt="image"></p><p>A的信号可以覆盖到B但不能覆盖到C。C的信号可以覆盖到B，但不能覆盖到A。A在给B发送数据帧前，可以使用RTS帧来预约信道。尽管C收不到该RTS帧，但是C可以收到B发送给A的CTS帧，这样C就知道了信道将被占用多长时间，在这段时间内C都不会争用信道，即A给B发送数据帧时不会受到C的干扰。</p><h4 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h4><p><img src="image/image_86.png" alt="image"></p><p><img src="image/image_87.png" alt="image"></p><p><img src="image/image_88.png" alt="image"></p><h1 id="MAC地址、IP地址和ARP地址"><a href="#MAC地址、IP地址和ARP地址" class="headerlink" title="MAC地址、IP地址和ARP地址"></a>MAC地址、IP地址和ARP地址</h1><ul><li>MAC地址是以太网的MAC子层所使用的地址；</li><li>IP地址是TCP/IP体系结构网际层所使用的地址；</li><li>ARP协议属于TCP/IP体系结构的网际层，其作用是已知设备所分配到的IP地址，使用ARP协议可以通过该IP地址获取到设备的MAC地址。</li></ul><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><img src="image/image_89.png" alt="image"></p><p><img src="image/image_90.png" alt="image"></p><ul><li>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址；</li><li>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制MAC，因此这类地址称为MAC地址；（MAC地址一般被固化在网卡（网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址被称为硬件地址）；</li></ul><p><img src="image/image_91.png" alt="image"></p><p><img src="image/image_92.png" alt="image"></p><p><img src="image/image_93.png" alt="image"></p><p>主机C发送给主机D的帧，则在帧首部中的目的地址字段，填入主机D的MAC地址，在源地址字段，填入主机C的MAC地址。这样，总线上其他各主机收到该帧后，就可以根据帧首部中的目的地址字段的值，是否与自己的MAC地址相匹配，进而丢弃或接受该帧。</p><ul><li>一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</li></ul><h3 id="MAC地址格式"><a href="#MAC地址格式" class="headerlink" title="MAC地址格式"></a>MAC地址格式</h3><p><img src="image/image_94.png" alt="image"></p><p><img src="image/image_95.png" alt="image"></p><p><img src="image/image_96.png" alt="image"></p><p><img src="image/image_97.png" alt="image"></p><h3 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h3><p><img src="image/image_98.png" alt="image"></p><p>主机B首先构建单播帧，在帧首部中的目的地址字段填入主机C的MAC地址，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，构成该单播帧。</p><p><img src="image/image_99.png" alt="image"></p><p>主机A的网卡发现该单播帧的目的MAC地址与自己的MAC地址不匹配，丢弃该帧。主机C的网卡发现该单播帧的目的MAC地址与自己的MAC地址匹配，接受该帧并将该帧交给上层处理。</p><h3 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h3><p><img src="image/image_100.png" alt="image"></p><p><img src="image/image_101.png" alt="image"></p><h3 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h3><p><img src="image/image_102.png" alt="image"></p><p><img src="image/image_103.png" alt="image"></p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>IP地址是因特网上的主机和路由器所使用的地址，用于标识两部分信息：网络编号（标识网络上数以百万计的网络）；主机编号（标识同一网络上不同主机或路由器各接口）；</p><p>MAC地址不具备区分不同网络功能，如果只是一个单独的网络，不接入因特网，可以只使用MAC地址（这不是一般用户的应用方式）；如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用。</p><p><img src="image/image_104.png" alt="image"></p><p><img src="image/image_105.png" alt="image"></p><p><strong>数据包转发过程中IP地址与MAC地址的变化情况</strong></p><p><img src="image/image_106.png" alt="image"></p><p><img src="image/image_107.png" alt="image"></p><p>数据包转发过程中源IP地址和目的IP地址保持不变；</p><p>数据包转发过程中源MAC地址和目的MAC地址逐个链路（或逐个网络）改变。</p><h3 id="练习-4"><a href="#练习-4" class="headerlink" title="练习"></a>练习</h3><p><img src="image/image_108.png" alt="image"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><img src="image/image_109.png" alt="image"></p><p>每个主机都有一个ARP高速缓存表</p><p><img src="image/image_110.png" alt="image"></p><p><img src="image/image_111.png" alt="image"></p><p><img src="image/image_112.png" alt="image"></p><p><img src="image/image_113.png" alt="image"></p><p>动态类型：自动获取，生命周期默认为两分钟；静态类型：手工设置，不同操作系统下的生命周期不同，例如系统重启后不存在或系统重启后依然有效。</p><p><img src="image/image_114.png" alt="image"></p><p>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用，本例ARP协议的使用是逐段链路进行的。</p><h1 id="集线器与交换机"><a href="#集线器与交换机" class="headerlink" title="集线器与交换机"></a>集线器与交换机</h1><p><img src="image/image_115.png" alt="image"></p><p><img src="image/image_116.png" alt="image"></p><h2 id="使用集线器HUB在物理层扩展以太网"><a href="#使用集线器HUB在物理层扩展以太网" class="headerlink" title="使用集线器HUB在物理层扩展以太网"></a>使用集线器HUB在物理层扩展以太网</h2><p><img src="image/image_117.png" alt="image"></p><p><img src="image/image_118.png" alt="image"></p><p>假设某学院下设三个系部，每个系部都有一个使用集线器作为互连设备的以太网。这三个以太网相互独立，各自共享自己的总线资源，是三个独立的碰撞域或称冲突域。例如，一系中的某台主机给另一台主机发送数据帧，由于总线特性，表示该数据帧的信号会传输到一系中的其他各主机。</p><p>二系中的多台主机同时发送数据帧，由于总线特性，这必然会产生信号碰撞，碰撞后的信号会传输到二系中的各主机。为了使各系部的以太网能够相互通信，可再使用一个集线器将它们互连起来。这样，原来三个独立的以太网，就互连成为了一个更大的以太网，而原来三个独立的碰撞域，就合并成了一个更大的碰撞域（形成更大的总线型以太网）。</p><p>一系中的某台主机给二系中的某台主机发送数据帧，由于总线特性，表示该数据帧的信号，会传输到整个网络中的其他各主机。</p><h2 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h2><p><img src="image/image_119.png" alt="image"></p><p>在集线器之后，发展出了更先进的网络互连设备（以太网交换机）。使用集线器互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到总线上的其他各个主机。</p><p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，而不是网络中的其他各个主机。</p><p><img src="image/image_120.png" alt="image"></p><p><img src="image/image_121.png" alt="image"></p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><img src="image/image_122.png" alt="image"></p><h1 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>以太网交换机工作在数据链路层（也包括物理层）</li><li>以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li><li>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，以太网交换机通过自学习算法自动逐渐建立起帧交换表。</li></ul><p><img src="image/image_123.png" alt="image"></p><p>假设各主机知道网络中其他各主机的MAC地址（无需进行ARP），假设主机A给主机B发送帧，该帧从交换机1的接口进入交换机1。交换机1首先进行登记工作，将该帧的源MAC地址A，记录到自己的帧交换表中，将该帧进入自己的接口的接口号1相应地也记录到帧交换表中，该登记工作称为交换机自学习。</p><p>交换机对该帧进行转发，该帧的目的MAC地址是B，在帧交换表中查找MAC地址B，没找到，于是对该帧进行盲目泛洪。主机B的网卡收到该帧后，根据帧的目的MAC地址B，就知道这是发送给自己的帧，接受该帧。主机C网卡收到该帧，根据帧的目的MAC地址B，发现不是发送给自己的帧，丢弃该帧。</p><p>该帧从交换机2的接口2进入交换机2，交换机2首先进行登记工作，将该帧源MAC地址A，记录到自己的帧交换表中，将该帧进入自己的接口的接口号2，相应地也记录到帧交换表中。之后，交换机2对该帧进行转发。该帧的目的MAC地址是B，在帧交换表中查找MAC地址B，没找到，于是对该帧进行盲目泛洪。主机D，E，F都会收到该帧，根据帧的目的MAC地址B，发现不是发送给自己的帧，丢弃该帧。</p><p><img src="image/image_124.png" alt="image"></p><p>主机B给主机A发送帧，该帧从交换机1的接口3进入交换机1，交换机1首先进行登记工作，将该帧的源MAC地址B，记录到自己的交换表中，将该帧进入自己接口的接口号3，相应地记录到帧交换表中。之后，交换机1对该帧进行转发。该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，找到并按照MAC地址A所对应的接口号1，从接口1转发该帧。主机A的网卡收到该帧后，根据帧的目的MAC地址A，就知道这是发送给自己的帧，接受该帧。</p><p><img src="image/image_125.png" alt="image"></p><p>主机E给主机A发送帧，该帧从交换机3的接口3进入交换机2，交换机2首先进行登记工作，之后，交换机2对该帧进行转发。该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，找到并按照MAC地址A所对应的接口号2，从接口2转发该帧。该帧从交换1的接口4进入交换机1，交换机1首先进行登记工作，之后，交换机1对该帧进行转发。该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，找到并按照MAC地址A所对应的接口号1，从接口1转发该帧。主机A的网卡收到该帧后，根据帧的目的MAC地址A，就知道这是发送给自己的帧，接受该帧。</p><p><img src="image/image_126.png" alt="image"></p><p>主机A、G、交换1的接口1共享同一条总线。假设主机G给主机A发送帧，该帧通过总线进行传输，主机A和交换机1的接口1都可以收到。主机A的网卡收到该帧后，根据帧的目的MAC地址A，就知道这是发送给自己的帧，接受该帧。交换机1收到该帧后，首先进行登记工作，之后，交换机1对该帧进行转发。该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，找到并按照MAC地址A所对应的接口号1，从接口1转发该帧。但是该帧正是从接口1进入交换机1的，交换机1不会再从该接口将该帧转发出去，因为这是没有必要的，于是丢弃该帧。</p><p><img src="image/image_127.png" alt="image"></p><h2 id="练习-5"><a href="#练习-5" class="headerlink" title="练习"></a>练习</h2><p><img src="image/image_128.png" alt="image"></p><p><img src="image/image_129.png" alt="image"></p><p><img src="image/image_130.png" alt="image"></p><h1 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h1><p><img src="image/image_131.png" alt="image"></p><p>如果交换机A与B的链路出现故障，则交换机B上连接的所有主机，既无法与交换机A上连接的所有主机进行通信，也无法与交换机C上连接的所有主机进行通信。</p><p><img src="image/image_132.png" alt="image"></p><p>解决：给交换机B和C直接添加一条冗余链路后，即使交换机A和B之间的链路出现了故障，整个网络还是连通的。提高以太网可靠性可以添加冗余链路，但是冗余链路也会带来负面效应—形成网络环路。如广播风暴（大量消耗网络资源，使得网络无法正常转发其他数据帧；主机反复收到广播帧，大量消耗主机资源；主机的帧交换表震荡（漂移））。</p><p><img src="image/image_133.png" alt="image"></p><p>假设主机H1发送了一个广播帧，交换机B收到该帧后，将其从自己的其他所有接口转发出去。交换机A收到交换机B转发来的该帧后，将其从自己的其他所有接口转发出去。同样，交换机C收到交换机B转发来的该帧后，将其从自己的其他所有接口转发出去….该广播帧将在各交换机之间反复转发，分别按顺时针和逆时针方向同时兜圈，即广播风暴。</p><p><img src="image/image_134.png" alt="image"></p><p><img src="image/image_135.png" alt="image"></p><p>假设各主机名称作为其MAC地址，当交换机B收到主机H1发送的广播帧后，进行登记工作，将帧的源MAC地址H1和帧进入交换机B的接口号1登记到帧交换表中。当交换机B再次收到交换机C转发来的该广播帧后，将帧的源MAC地址H1和帧进入交换机B的接口号2，错误记录登记到帧交换表中，并删除原先正确的记录。当交换机B再次收到交换机A转发来的该广播帧后，将帧的源MAC地址H1和帧进入交换机B的接口号3，错误记录登记到帧交换表中；当交换机B再次收到交换机C转发来的该广播帧后，将帧的源MAC地址H1和帧进入交换机B的接口号2，错误记录登记到帧交换表中。有关MAC地址H1的记录，将在这两个错误记录之间反复震荡。</p><p><img src="image/image_136.png" alt="image"></p><p><img src="image/image_137.png" alt="image"></p><p>按照生成树协议中规定生成树算法，交互一些参数后，就可以判断出自己应该阻塞自己的哪些接口。这样就会形成一个逻辑上没有环路的网络。</p><p><img src="image/image_138.png" alt="image"></p><p>假设某段链路出现了故障，相关交换机检测到该故障后，重新计算生成树，决定将自己之前阻塞的接口恢复为正常状态，这样就会形成一个新的逻辑上没有环路的网络。</p><h1 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><img src="image/image_139.png" alt="image"></p><p><img src="image/image_140.png" alt="image"></p><p><img src="image/image_141.png" alt="image"></p><p><img src="image/image_142.png" alt="image"></p><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><h3 id="IEEE802-1Q帧"><a href="#IEEE802-1Q帧" class="headerlink" title="IEEE802.1Q帧"></a>IEEE802.1Q帧</h3><p><img src="image/image_143.png" alt="image"></p><h3 id="交换机的端口类型"><a href="#交换机的端口类型" class="headerlink" title="交换机的端口类型"></a>交换机的端口类型</h3><p>交换机的端口类型有以下三种:Access、Trunk、Hybrid。</p><p>在交换机各端口的缺省VLAN ID，在思科交换机上称为Native VLAN，即本征VLAN；在华为交换机上称为Port VLAN ID, 即端口VLAN ID,简记为PVID。</p><h4 id="Access端口"><a href="#Access端口" class="headerlink" title="Access端口"></a>Access端口</h4><p><img src="image/image_144.png" alt="image"></p><p>假设主机A发送了一个广播帧，该帧从交换机的端口1进入交换机。由于端口1的类型是Access，它会对接收到的“未打标签”的普通以太网MAC帧“打标签”，即插入4字节VLAN标记字段，由于端口1的PVID值等于1，因此，所插入的4字节VLAN标记字段中的VID的值也等于1。广播帧中的VID的取值与端口2，3，4的VID的取值与端口2，3，4的PVID取值都等于1，因此，交换机会从这三个端口对帧进行“去标签”转发。</p><p><img src="image/image_145.png" alt="image"></p><p>假设主机A发送了一个广播帧，该帧从交换机的端口1进入交换机。由于端口1的类型是Access，它会对接收到的“未打标签”的普通以太网MAC帧“打标签”，即插入4字节VLAN标记字段，由于端口1的PVID值等于2，因此，所插入的4字节VLAN标记字段中的VID的值也等于2。广播帧中的VID的取值与端口2的VID的取值与端口2的PVID取值等于2，因此，交换机会从该端口对帧进行“去标签”转发。</p><h4 id="Trunk端口"><a href="#Trunk端口" class="headerlink" title="Trunk端口"></a>Trunk端口</h4><p><img src="image/image_146.png" alt="image"></p><p>假设主机A发送了一个广播帧，该帧从交换机的端口1进入交换机。由于端口1的类型是Access，它会对接收到的“未打标签”的普通以太网MAC帧“打标签”，即插入4字节VLAN标记字段，由于端口1的PVID值等于1，因此，所插入的4字节VLAN标记字段中的VID的值也等于1。广播帧中的VID的取值与端口2的VID的取值与端口2的PVID取值都等于1，端口2的类型是Access，因此，交换机会从该端口对帧进行“去标签”转发。</p><p>该广播帧中的VID的取值与端口的PVID值都等于1，端口5的类型是Trunk。因此，交换机1会从端口5对帧进行“去标签”转发。交换机2会对接收到的“未打标签”的普通以太网MAC帧“打标签”，即插入4字节的VLAN标记字段。由于端口的PVID值等于1，因此，所插入的4字节VLAN标记字段中的VID的值也等于1。该广播帧的VID取值与端口1和2的PVID值都等于1，端口1和2的类型都是Access，因此，交换机2会从端口1和2对帧进行“去标签”转发。</p><p><img src="image/image_147.png" alt="image"></p><blockquote><p>连接主机的交换机端口应设置为Access类型，交换机之间互连端口应设置为Trunk类型。</p></blockquote><h4 id="Hybrid端口"><a href="#Hybrid端口" class="headerlink" title="Hybrid端口"></a>Hybrid端口</h4><p><img src="image/image_148.png" alt="image"></p><p><img src="image/image_149.png" alt="image"></p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.icourse163.org/course/HNKJ-1461816178">计算机网络_湖南科技大学_中国大学MOOC(慕课) (icourse163.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;链路就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。实现通信协议的硬件和软件加到链路上，就构成了数据链路。数据链路层以帧尾单位传输和处理数据。封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="数据链路层" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="数据链路层" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://github.com/LittleWills/GameWill.github.io.git/2021/11/29/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://github.com/LittleWills/GameWill.github.io.git/2021/11/29/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2021-11-29T13:04:10.000Z</published>
    <updated>2022-04-30T16:37:48.359Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>物理层解决在各种传输媒体上传输比特0和1的问题，进而给数据链路层提供透明传输比特流的服务。“透明”是指数据链路层看不见，无需看见物理层究竟使用的是什么方法来传输比特0和1的。它只管享受物理层提供的比特流传输服务即可。物理层为了解决在各种传输媒体上传输比特0和1的问题，主要有四个任务：机械特性、电器特性、功能特性、过程特性。</p></blockquote><span id="more"></span><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="image/image_P5sZoBTBDF.png" alt="image"></p><p>物理层解决在各种传输媒体上传输比特0和1的问题，进而给数据链路层提供透明传输比特流的服务。“透明”是指数据链路层看不见，无需看见物理层究竟使用的是什么方法来传输比特0和1的。它只管享受物理层提供的比特流传输服务即可。</p><p>物理层为了解决在各种传输媒体上传输比特0和1的问题，主要有四个任务：</p><p>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</p><p>电器特性：指明在接口电缆的各条线上出现的电压范围。</p><p>功能特性：指明某条线上出现的某一电平的电压表示何种意义。</p><p>过程特性：指明对于不同功能的各种可能事件的出现顺序。</p><h1 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h1><p>传输媒体不属于计算机网络体系结构的任何一层，如果非要将其添加到体系结构中，那么归类为物理层之下的传输媒体。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><p>电磁波被导引沿着固体媒体传播。</p><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="image/image_dA6kkcKu69.png" alt="image"></p><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p><img src="image/image_8JAJmNmNjH.png" alt="image"></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="image/image_7eE1xBNTHw.png" alt="image"></p><p><img src="image/image_NnWlvaY1Hs.png" alt="image"></p><p><img src="image/image_6pupolu2cX.png" alt="image"></p><h3 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h3><p><img src="image/image_TQmxPHrdWE.png" alt="image"></p><p>应用电力线传输信号的实例最早是电力线电环。目前，如果要构建家庭高性能局域网，采用电力线作为传输媒体是不能满足要求的。对于装修时没有进行网络布线的家庭，可以采用该方式。对于一些采用独立房间进行办公的企业来说，每间办公室电脑数量不多，而又不希望跨办公室进行布线，也可采取该方式。每个办公室只需根据需求，在电源插座上插入一个或多个电力猫即可。</p><h2 id="非导引传输媒体"><a href="#非导引传输媒体" class="headerlink" title="非导引传输媒体"></a>非导引传输媒体</h2><p>自由空间</p><p>无线电波、微波、红外线、可见光</p><p><img src="image/image_-ri3DmYr5Q.png" alt="image"></p><p><img src="image/image_5H1Th9VmlJ.png" alt="image"></p><p><img src="image/image_-CJHHM43kR.png" alt="image"></p><p>无线电波中的低频和中频频段，主要利用地面波进行传输；而高频和甚高频，主要靠电离层的反射。</p><h3 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h3><p><img src="image/image_2IC1cJCmga.png" alt="image"></p><p>微波通信在数据通信中占有重要地位。微波在空间主要是直线传播，由于微波会穿透电离层而进入宇宙空间，因此它不能经过电离层的反射传播到地面上很远的地方。</p><p>传统微波通信两种方式：地面微波接力通信和卫星通信。</p><p>因为地球表面是曲面，因此其传播距离受到限制，一般只有公里左右，但若采用100米高的天线塔，则传播距离可增大到100公里。为实现远距离通信，必须在一条微波通信信道的两个终端之间建立若干个中继站。中继站把前一站送来的信号经过放大后再发送到下一站，故称为“接力”。</p><p><img src="image/image_Vj-XTZq4Ao.png" alt="image"></p><p><img src="image/image_-Ixf7uIcuf.png" alt="image"></p><p>常用的卫星通信方法是在地球站之间，利用位于约3万6千公里高空的人造同步地球卫星，作为中继器的一种微波接力通信，其最大特点是通信距离远。传播时延比较大，一般在250~300ms之间。除同步卫星外，低轨道卫星通信系统已开始在空间部署，并构成了空间告诉链路。</p><h3 id="红外线"><a href="#红外线" class="headerlink" title="红外线"></a>红外线</h3><p><img src="image/image_ZJ6QcL-kQG.png" alt="image"></p><p>很多智能手机还带有红外接口，以方便用户对电视、空调等家用电器进行红外遥控。</p><p><img src="image/image_91mt_CibfO.png" alt="image"></p><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><h2 id="串行传输-并行传输"><a href="#串行传输-并行传输" class="headerlink" title="串行传输/并行传输"></a>串行传输/并行传输</h2><p><img src="image/image_2SbZi-2Wsp.png" alt="image"></p><p>远距离传输采用串行传输；CPU与内存之间，通过总线进行数据传输。常见的数据总线宽度有8位、16位、32位和64位。</p><h2 id="同步传输-异步传输"><a href="#同步传输-异步传输" class="headerlink" title="同步传输/ 异步传输"></a>同步传输/ 异步传输</h2><p><img src="image/image_xLTKnxANxx.png" alt="image"></p><p>采用同步传输方式数据块以稳定的比特流的形式传输，字节之间没有间隔。接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1。由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差会导致接收端对比特信号的判别错位。因此需要采取方法使收发双方的时钟保持同步。</p><h2 id="单向-双向交替-双向同时通信"><a href="#单向-双向交替-双向同时通信" class="headerlink" title="单向/双向交替/双向同时通信"></a>单向/双向交替/双向同时通信</h2><p><img src="image/image_MkVrwU76Dh.png" alt="image"></p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="image/image_NzFXTk-Vt-.png" alt="image"></p><p>在计算机网络中，计算机需要处理和传输用户的文字，图片，音频和视频，它们可以统称为消息。数据是运送消息的实体，计算机只能处理二进制数据，也就是比特0和比特1，变换成相应的电信号发送到网线。也就是信号是数据的电磁表现，由信源发出的原始电信号称为基带信号。</p><p>基带信号可分为两类，数字基带信号（计算机内部CPU和内存之间传输的信号）和模拟基带信号（麦克风收到声音后产生的音频信号）。信号需要在信道中进行传输，信道可分为数字信道和模拟信道两种。在不改变信号性质的前提下，仅对数字基带信号的波形进行变换，称为编码。编码后产生的信号仍未数字信号，可以在数字信道中传输。例如，以太网使用曼彻斯特编码等。把数字基带信号的频率范围，搬移到较高的频段，并转换为模拟信号，称为调制。调制后产生的信号是模拟信号，可以在模拟信道中传输。例如，WIFI使用补码键控、直接序列扩频、正交频分复用等调制方法。</p><p>对于模拟基带信号的处理，也有编码和调制两种方法，对模拟基带信号进行编码的典型应用是对音频信号进行编码的脉码调制PCM，也就是将模拟音频信号，通过采样、量化、编码三个步骤进行数字化。对模拟信号进行调制的典型应用是将语音数据加载到模拟的载波信号中传输，例如传统的电话，另一个是频分复用FDM技术，可以充分利用带宽资源。</p><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形称为码元。码元就是构成信号的一段波形。</p><p><img src="image/image_9HwrAtNHSV.png" alt="image"></p><p>传输媒体和信道的关系：严格来说传输媒体和信道不能直接划等号，对于单工传输，传输媒体中只包含一个信道。要么是发送信道，要么是接收信道。而对于半双工和全双工传输，传输媒体中要包含两个信道。一个是发送信道，另一个是接收信道。如果使用信道复用技术，一条传输媒体还可以包含多个信道。在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输。</p><h2 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h2><p><img src="image/image_bLl6RSx2tC.png" alt="image"></p><p><img src="image/image_ToLBuOmRyE.png" alt="image"></p><p>图中采用不归零编码产生的该比特流的相应信号。正电平表示比特1，负电平表示0。所谓不归零，就是指在整个码元时间内，电平不会出现零电平。该编码存在同步问题，因此计算机网络中不采用该编码。</p><p><img src="image/image_8BD81ZiWJs.png" alt="image"></p><p>归零编码，每个码元传输结束后信号都要“归零”。优点自同步，但编码效率低。</p><p><img src="image/image_ssfX7VYtNT.png" alt="image"></p><p>差分曼彻斯特编码比曼彻斯特编码变化少，更适合较高的传输速率。</p><p><img src="image/image_1HLfNTtp56.png" alt="image"></p><h2 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h2><p><img src="image/image_xZwqsaS4SF.png" alt="image"></p><p><strong>使用基本调制方法，1个码元只能包含1个比特信息。如何能使1个码元包含更多的比特呢？</strong></p><p><img src="image/image_KwXq0KKvYl.png" alt="image"></p><p><img src="image/image_ZmcKSQs9Ny.png" alt="image"></p><p><strong>混合调制举例 - 正交振幅调制QAM</strong></p><p><img src="image/image_7P6XvCQmic.png" alt="image"></p><p><img src="image/image_-xIDt0piVF.png" alt="image"></p><p><img src="image/image_g-Jtwrw6B-.png" alt="image"></p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src="image/image_G5tC_rdrGd.png" alt="image"></p><p>信号在传输过程中会收到各种因素的影响。当失真不严重时，在输出端还可根据已失真的波形还原出发送的码元。但当失真严重时，在输出端就很难判断这个信号在什么时候是1和什么时候是0。信号波形失去了码元之间的清晰界限，这种现象叫做码间串扰。</p><p><img src="image/image_Z3U0ak0cmq.png" alt="image"></p><p><img src="image/image_RwgVST2jIh.png" alt="image"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="image/image_1_duaCe3er.png" alt="image"></p><p><img src="image/image_u7V1ulGP5n.png" alt="image"></p><p><img src="image/image_C-hV027ozw.png" alt="image"></p><p><img src="image/image_1idxKGrHOa.png" alt="image"></p><p><img src="image/image_Gc0ygPZfLo.png" alt="image"></p><p><img src="image/image_XxIlBdQHcg.png" alt="image"></p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.icourse163.org/course/HNKJ-1461816178">计算机网络_湖南科技大学_中国大学MOOC(慕课) (icourse163.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;物理层解决在各种传输媒体上传输比特0和1的问题，进而给数据链路层提供透明传输比特流的服务。“透明”是指数据链路层看不见，无需看见物理层究竟使用的是什么方法来传输比特0和1的。它只管享受物理层提供的比特流传输服务即可。物理层为了解决在各种传输媒体上传输比特0和1的问题，主要有四个任务：机械特性、电器特性、功能特性、过程特性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="物理层" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="物理层" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://github.com/LittleWills/GameWill.github.io.git/2021/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://github.com/LittleWills/GameWill.github.io.git/2021/11/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2021-11-22T10:47:13.000Z</published>
    <updated>2022-04-30T16:40:40.771Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某以特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。计算机网络并非专门用来传送数据，而是能够支持很多种的应用。</p></blockquote><span id="more"></span><h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="image.png" alt="image"></p><p>因为计算机数据是突发是地出现在传输线路上，当用户正在输入和编辑一份待传输的文件时，用户所占用的通信资源暂时未被利用，该通信资源也不能被其他用户利用，宝贵的通信线路资源白白被浪费。因此计算机网络通常采用分组交换，而不是电路交换。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="image_1.png" alt="image_1"></p><p>假设主机H6的用户要给主机H2的用户发送一条消息，通常我们把表示该消息的整块数据称为一个报文。在发送报文之前，先把较长的报文划分称为一个个更小的等长数据段。在每一个数据段前面，加上一些有必要的控制信息组成的首部后，就构成了一个分组，也可简称为“包”，首部称为“包头”。首部中包含了分组的目的地址，否则分组传输路径中的各分组交换机（路由器），就不知道如何转发分组了。分组交换机收到一个分组后，先将分组暂时存储下来，再检查其首部，按照首部中的目的地址进行查表转发，找到合适1的转发接口，通过该接口将分组转发给下一个分组交换机。</p><p><img src="image_2.png" alt="image_2"></p><p>主机H6将所构造出的各分组依次发送出去，各分组经过途中各分组交换机的存储转发，最终到达主机H2。</p><p><img src="image_3.png" alt="image_3"></p><p>主机H2收到这些分组后，去掉它们的首部，将个数据端组合还原出原始报文。</p><p>分组传输过程中其中两种情况（分组丢失、误码、重复…）</p><ol><li>各分组从源站到达目的站可以走不同的路径（也就是不同的路由）；</li><li>分组乱序（分组到达目的站的顺序不一定与分组在源站的发送顺序相同）。</li></ol><p><img src="image_4.png" alt="image_4"></p><p>发送方所要完成的任务是构造分组和发送分组，路由器（分组交换机）所要完成的任务是缓存分组和转发分组（存储转发），接收方所要完成的任务是接收分组和还原报文。与分组类似，报文交换中的交换结点也采用存储转发方式。但报文交换对报文的大小没有限制，这就要求交换结点需要有较大的缓存空间。报文交换主要用于早起的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。</p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><h3 id="三种交换方式对比"><a href="#三种交换方式对比" class="headerlink" title="三种交换方式对比"></a>三种交换方式对比</h3><p><img src="image_5.png" alt="image_5"></p><p>假设A，B，C，D是分组传输路径上所要经过的4个结点交换机，纵坐标为时间，对于电路交换，通信之前要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送结束后，需要释放连接，以归还之前建立连接所占用的通信线路资源。</p><p>对于报文交换，可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</p><p>对于分组交换，可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各节点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</p><p>当使用电路交换时，一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</p><p>当使用报文交换时，整个报文需要在各结点交换机上进行存储转发，由于不限制报文的大小，因此需要各结点交换机都具有较大的缓存空间。</p><p>当使用分组交换时，构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</p><h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单定义：一些互相连接的、自治的计算机集合。</p><p>互连：指计算机之间可以通过有线或无线的方式进行数据通信；</p><p>自治：指独立的计算机，它有自己的硬件和软件，可以单独运行使用；</p><p>集合：指至少需要两台计算机</p><p>现阶段较好的定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某以特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</p><p>计算机网络并非专门用来传送数据，而是能够支持很多种的应用。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="image_6.png" alt="image_6"></p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img src="image_7.png" alt="image_7"></p><p><img src="image_8.png" alt="image_8"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><img src="image_9.png" alt="image_9"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><img src="image_10.png" alt="image_10"></p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p><img src="image_11.png" alt="image_11"></p><p><img src="image_12.png" alt="image_12"></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p><img src="image_13.png" alt="image_13"></p><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p><img src="image_14.png" alt="image_14"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="image_15.png" alt="image_15"></p><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p><img src="image_16.png" alt="image_16"></p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="常见计算机网络体系结构"><a href="#常见计算机网络体系结构" class="headerlink" title="常见计算机网络体系结构"></a>常见计算机网络体系结构</h3><p><img src="image_17.png" alt="image_17"></p><p><img src="image_18.png" alt="image_18"></p><h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p><img src="image_19.png" alt="image_19"></p><p><img src="image_20.png" alt="image_20"></p><p><img src="image_21.png" alt="image_21"></p><p><img src="image_22.png" alt="image_22"></p><p><img src="image_23.png" alt="image_23"></p><p><img src="image_24.png" alt="image_24"></p><h3 id="分层思想举例"><a href="#分层思想举例" class="headerlink" title="分层思想举例"></a>分层思想举例</h3><p><img src="image_25.png" alt="image_25"></p><p>应用层按HTTP协议的规定，构建一个HTTP请求报文，应用层将HTTP请求报文交付给运输层处理。</p><p><img src="image_26.png" alt="image_26"></p><p>运输层给HTTP请求报文添加一个TCP首部使之成为TCP报文段，TCP报文段的首部的作用主要是为了区分应用进程以及实现可靠传输。运输层将TCP报文段交付给网络层处理。</p><p><img src="image_27.png" alt="image_27"></p><p>网络层给TCP报文段添加一个IP首部使之成为IP数据报，IP数据报的首部的作用主要是为了使IP数据报可以再互联网上传输，即被路由器转发。网络层将IP数据报交付给数据链路层处理。</p><p><img src="image_28.png" alt="image_28"></p><p>数据链路层给IP数据报添加一个首部和一个尾部使之成为帧，以太网帧首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收；以太网帧尾部的作用是为了让目的主机检查所接收到的帧是否有误码。数据链路层将帧交给物理层。</p><p><img src="image_29.png" alt="image_29"></p><p>物理层将帧看作是比特流，由于N1是以太网，因此物理层会给比特流前面添加前导码，前导码作用是为了让目的主机做好接收帧的准备。物理层将添加有前导码的比特流，变换成相应的信号发送到传输媒体，信号通过传输媒体到达路由器。</p><p><img src="image_30.png" alt="image_30"></p><p>路由器物理层将信号变换为比特流，去掉前导码后，将其交付给数据链路层。</p><p><img src="image_31.png" alt="image_31"></p><p>数据链路层将帧的首部和尾部去掉后，将其交付给网络层。</p><p><img src="image_32.png" alt="image_32"></p><p>网络层解析IP数据报的首部，从中提取出目的网络地址，然后查找自身的路由表，确定转发端口，以便进行转发，网络层将IP数据报交付给数据链路层。</p><p><img src="image_33.png" alt="image_33"></p><p>数据链路层给IP数据报添加一个首部和一个尾部使之成为帧。数据链路层将帧交付给物理层。</p><p><img src="image_34.png" alt="image_34"></p><p>物理层将帧看做是比特流，由于N2是以太网，因此物理层会给比特流前面添加前导码，物理层将添加有前导码的比特流，变换成相应的信号发送到传输媒体。信号通过传输媒体到达web服务器。</p><p><img src="image_35.png" alt="image_35"></p><p>web服务器物理层将信号变换为比特流，去掉前导码后，将其交付给数据链路层。</p><p><img src="image_36.png" alt="image_36"></p><p>数据链路层将帧的首部和尾部去掉后，将其交付给网络层。</p><p><img src="image_37.png" alt="image_37"></p><p>网络层将IP数据报的首部去掉后，将其交付给运输层。</p><p><img src="image_38.png" alt="image_38"></p><p>运输层将TCP报文段的首部去掉后，将其交付给应用层。</p><p><img src="image_39.png" alt="image_39"></p><p>应用层对HTTP请求报文进行解析，然后给主机发回HTTP响应报文。</p><p><img src="image_40.png" alt="image_40"></p><p>与之前的过程类似，HTTP响应报文需要在Web服务器层层封装，然后通过物理层换成相应的信号，再通过传输媒体传输到路由器。路由器转发该响应报文给主机。主机通过物理层将收到的信号转换成比特流。之后通过逐层解封，最终取出HTTP响应报文。</p><h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p><img src="image_41.png" alt="image_41"></p><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p><img src="image_42.png" alt="image_42"></p><p>协议三要素：语法、语义、同步</p><p>语法： 定义所交换信息的格式（定义了所交换信息由哪些字段以及顺序构成）</p><p><img src="image_43.png" alt="image_43"></p><p>语义：定义收发双方所要完成的操作</p><p>HTTP语义规定：主机要访问远程Web服务器，它会构建一个HTTP的Get请求报文，然后将其发送给Web服务器。Web服务器收到该报文并进行解析，知道这是一个HTTP的GET请求报文。于是就在自身内部查找所请求的内容， 并将所找到的内容封装在一个HTTP响应报文中发回给主机。主机收到HTTP响应报文后，对其进行解析，取出所请求的内容并由浏览器解析显示。</p><p>同步：定义收发双发的时序关系</p><p><img src="image_44.png" alt="image_44"></p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p><img src="image_45.png" alt="image_45"></p><p><img src="image_46.png" alt="image_46"></p><p><img src="image_47.png" alt="image_47"></p><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://www.icourse163.org/course/HNKJ-1461816178">计算机网络_湖南科技大学_中国大学MOOC(慕课) (icourse163.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某以特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。计算机网络并非专门用来传送数据，而是能够支持很多种的应用。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="概述" scheme="https://github.com/LittleWills/GameWill.github.io.git/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%BF%B0/"/>
    
    
    <category term="计算机网络" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="计算机网络概述" scheme="https://github.com/LittleWills/GameWill.github.io.git/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
</feed>
