<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Actor模型</title>
    <url>/GameWill.github.io/2021/12/25/Actor%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>Gul Agha提出了两个论点:一个Actor对象可以创建其他Actor对象；一个顺序进程无法创建其他顺序进程。<br>这两个论点并非贬低顺序程序的作用。而且也不是说，一个顺序进程无法执行其他顺序进程（数十年的主流开发经验已经证明了这一点）。但是，顺序进程仍旧是静态的，而且只能完成专门化的任务。与此相比，在高动态环境（在这种环境中可以根据需要创建和删除Actor对象，甚至可以在运行程序时，根据领域或操作环境需求更改Actor对象的行为）中，Actor 模型既可以利用顺序编程技巧，也可以利用函数编程技巧。响应式系统不仅拥有并发性和分布性，而且还拥有弹性、动态性、响应性和韧性。</p>
</blockquote>
<span id="more"></span>
<h1 id="Actor模型"><a href="#Actor模型" class="headerlink" title="Actor模型"></a>Actor模型</h1><h1 id="Actor-模型的起源"><a href="#Actor-模型的起源" class="headerlink" title="Actor 模型的起源"></a>Actor 模型的起源</h1><p>Actor 模型是一种用于处理并发计算的数学模型，它将Actor 对象用作并发计算的通用基元。与其他计算模型不同，发明Actor模型的灵感源于物理学理论，如广义相对论和量子力学。<br>可以将Actor 模型视为创建响应式应用程序的手段之一。使用这种具体的响应式软件开发方法，可以细致地处理响应式应用程序的主要方面：响应性、韧性、弹性和消息驱动性。它通过消息传递方式实现这四个方面的功能。<br>Carl Hewitt 博士是Actor 软件开发模型的发明者，他为研究该模型投入了数十年时间。Carl Hewitt 博士发现某些计算问题需要使用并发和分布模式解决，但他在做这项研究时第一台晶体管计算机仅出现了14 年，还不存在多核处理器。在1973年，功能最强大的Intel 处理器仅含有4000 至5000 个晶体管，其主频还没有超过1MHz。Carl Hewitt 博士在研究Actor 模型时，能够使用的功能最强大的处理器。处理器的硬件能力无法将Carl Hewitt 提出的理论付诸实践。因此，当时分布式和并行系统知识的理论模型与现实情况不匹配。<br><img src="image.jpg" alt="image"><br><strong><center>1973 年左右功能最强大的处理器</center></strong></p>
<h1 id="了解Actor-模型"><a href="#了解Actor-模型" class="headerlink" title="了解Actor 模型"></a>了解Actor 模型</h1><p>Actor 是一种计算实体，它会对收到的消息做出回应，并且可以做下列事情：<br>■ 向其他Actor 对象发送一定数量的消息。<br>■ 创建一定数量的新Actor 对象。<br>■ 设定对下一条消息做出的回应方式。<br>执行这些操作的次序不分先后，而且可以通过并行方式执行它们。<br>在功能齐全的Actor 系统中，所有事物都是Actor 对象。这意味着我们通常使用的基本数据类型（如字符串和整型）都是Actor对象。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTAxMTgzOC8yMDE4MTEvMTAxMTgzOC0yMDE4MTExNTE0NTQwNjYwOS0xNjEyMDM0NjU0LnBuZw"><br>Actor 是由状态（state）、行为（behavior）、邮箱（mailbox）三者组成的：</p>
<ul>
<li>状态（state）：状态是指 actor 对象的变量信息，状态由 actor 自身管理，避免并发环境下的锁和内存原子性等问题。</li>
<li>行为（behavior）：行为指定的是 actor 中计算逻辑，通过 actor 接收到的消息来改变 actor 的状态。</li>
<li>邮箱（mailbox）：邮箱是 actor 之间的通信桥梁，邮箱内部通过 FIFO 消息队列来存储发送发消息，而接收方则从邮箱中获取消息。</li>
</ul>
<p>Actor 模型描述了一组为避免并发编程的公理：</p>
<ul>
<li>所有的 Actor 状态是本地的，外部是无法访问的。</li>
<li>Actor 必须通过消息传递进行通信</li>
<li>一个 Actor 可以响应消息、退出新 Actor、改变内部状态、将消息发送到一个或多个 Actor。</li>
<li>Actor 可能会堵塞自己但 Actor 不应该堵塞自己运行的线程</li>
</ul>
<hr>
<h2 id="并发线程通信方式"><a href="#并发线程通信方式" class="headerlink" title="并发线程通信方式"></a>并发线程通信方式</h2><p>一般而言，有两种策略用来在并发线程中进行通信：<strong>共享数据</strong>和<strong>消息传递</strong> 。</p>
<h3 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a><strong>共享数据</strong></h3><p>使用<strong>共享数据</strong> 的并发编程，一般会使用各种锁去处理相关的线程安全问题；但同时也要处理各种锁所带来的问题。</p>
<p><strong>死锁</strong> ：锁的设计不当，会出现两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去的现象。</p>
<p><strong>效率低：</strong> 在高度竞争的阶段，很有可能出现很长的线程队列，他们都在等待递减计数器。但使用队列的方式的问题在于可能造成众多阻塞线程，也就是每个线程都在等待轮到它们去执行一个序列化的操作。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>实现消息传递有两种常见类型：<strong>基于channel的消息传递</strong>和<strong>基于Actor的消息传递</strong> 。</p>
<p>和共享数据方式相比，消息传递机制最大的优势在于不会产生数据竞争状态。共享内存是倾向于强一致性弱隔离性的，例如悲观锁同步的方式就是使用强一致性的方式控制并发，而 Actor 模型天然是是强隔离性且弱一致性的，所以 Actor 模型在并发中有良好的性能，而且易于控制和管理。</p>
<h1 id="Actor消息传递避免数据竞争原理"><a href="#Actor消息传递避免数据竞争原理" class="headerlink" title="Actor消息传递避免数据竞争原理"></a>Actor消息传递避免数据竞争原理</h1><p>想象我们在抢火车票，有两个线程并发地调整计数器，该计数器目前的值是 5。线程一想要将计数器的值递减 3，而线程二想要将计数器的值递减 4。它们都会检查当前计数器的值，并且会断定计数器的值大于要递减的数量。然后，它们都会继续运行并递减计数器的值。最后的结果就是 5 - 4 - 3 = -2。这样的结果会造成货品的过度分配，违反了特定的业务规则。</p>
<p>现在，我们将基于线程的实现替换为 Actor。 当然，Actor 也要在线程中运行，但是 Actor 只有在有事情可做的时候才会使用线程。在我们的计数器场景中，请求者代表了 Customer Actor。门票的数量现在由 Actor 来维护，它持有当前计数器的状态。Customer Actor 和 Tickets Actor 在空闲时（也就是没有消息要处理）都不会持有线程。</p>
<p>要初始购买操作，Customer Actor 需要发送一条 buy 消息给一个 Tickets Actor。在这样的 buy 消息中包含了要购买的数量。当 Tickets Actor 接收到 buy 消息时，它会校验购买数量不超过当前剩余的数量。如果购买请求是合法的，数量就会递减，Tickets Actor 会发送一条信息给 Customer Actor，表明订单被成功接受。如果购买数量超出了剩余数量的话，Tickets Actor 将会发送给 Customer Actor 一条消息，表明订单被拒绝了。Actor 模型本身确保处理是按照同步的方式进行的。</p>
<p>我们分三步展示 actor 之间的交互：</p>
<ol>
<li>Customer Actor 发送 buy 消息</li>
<li>Tickets Actor 处理消息</li>
<li>Tickets Actor 拒绝购买请求</li>
</ol>
<p><strong>1.Customer Actor 发送 buy 消息：</strong>  Customer Actor，它们各自发送 buy 消息给 Tickets Actor。这些 buy 消息会在 Tickets Actor 的收件箱（mailbox）中排队。发送一条消息并未将 “执行线程” 从发送者转移到目标。一个 actor 可以发送一条消息并继续无阻塞地运行。因此，在同样的时间内，它可以完成更多任务。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvNzIvNjUvNzIyODA0ZmU3MzU4N2EwNDYzMjkxMWY1NGVjYTk1NjUuanBn"></p>
<p><strong><center>Customer Actor 发送 buy 消息</center></strong> </p>
<p><strong>2.Tickets Actor 处理消息：</strong> 如下展示的是请求购买五张门票的第一条消息。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvMzUvMmYvMzUyOWUwYzAyN2QxZWU3YWUyZDc2ZGI1OTRjYzI1MmYuanBn"></p>
<p><strong><center>Tickets Actor 处理消息</center></strong> </p>
<p>当一个 Tickets  Actor 收到一条消息时，Tickets  Actor 将这条消息添加到队列尾部，如果 Tickets  Actor 没有被调度执行，它将被标记为 ready。一个调度器获取这个 Tickets  Actor 并开始执行它：Tickets  Actor 在队列头部取出一条消息。</p>
<p>随后，Tickets Actor 检查购买数量没有超出剩余门票的数量。在当前的情况下，门票数量是 15，因此购买请求能够接受，剩余门票数量会递减，Tickets Actor 还会发送一条消息给发出请求的 Customer Actor，表明门票购买成功。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvMWMvNzcvMWMyZGZiYWVjZTg0ODMxMTdjYmZjNzhmYzViZGU0NzcuanBn"></p>
<p><strong><center>Tickets Actor 处理消息队列</center></strong></p>
<p>Tickets Actor 会处理其收件箱中的每条消息。需要注意，这里没有复杂的线程或锁。这是一个<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a>的处理过程，但是 Actor 系统会管理线程的使用和分配。</p>
<p>在这里 Actor 区别于多线程并发模型的是，多线程并发模型改变了 actor 并对内部状态，而 actor 独立处理收到的消息，并且它们一个一个地响应连续到来的消息。虽然每个 actor 连续地处理发给它的消息，不同的 actors 之间并发地工作，所以一个 actor 系统可以同时处理多条消息。因为每个 actor 中同时最多处理一个消息，所以 Actor 模型无需使用锁。</p>
<p><strong>3.Tickets Actor 拒绝购买请求：</strong>  当请求的数量超过剩余值时，Tickets Actor 会如何进行处理。这里所展现的是当我们请求两张门票，但是仅剩一张门票时的情况。Tickets Actor 会拒绝这个购买请求并向发起请求的 Customer Actor 发送一条 “sold out”的消息。</p>
<p><img src="image_2.png" alt="image_2"></p>
<p><strong><center>Tickets Actor 拒绝购买请求</center></strong></p>
<p>当然，在线程方面有一定经验的开发人员会知道，可划分为两个阶段的行为检查和门票数量递减能够通过同步的操作序列来完成。以在 Java 中为例，我们可以使用同步的方法或语句来实现。但是，基于 Actor 的实现不仅在每个 Actor 中提供了自然的操作同步，而且还能避免大量的线程积压，防止这些线程等待轮到它们执行同步代码区域。在门票样例中，每个 Customer Actor 会等待响应，此时不会持有线程。这样所形成的结果就是基于 Actor 的方案更容易实现，并且会明显降低系统资源的占用。</p>
<h1 id="Actor-系统和Actor-对象基本特点"><a href="#Actor-系统和Actor-对象基本特点" class="headerlink" title="Actor 系统和Actor 对象基本特点"></a>Actor 系统和Actor 对象基本特点</h1><p><strong>■ 直接通过异步消息传递方式进行通信：</strong> 如果Actor 对象A1 要向Actor 对象A2 发送消息M1，那么Actor 对象A1 就必须知道Actor 对象A2 的地址。如果Actor 对象A1 知道Actor 对象A2的地址，那么它就能够直接向Actor 对象A2 发送消息M1，但Actor 对象A2 会使用独立线程接收和处理消息M1。换言之，消息M1 是通过异步方式被发送给Actor 对象A2 的。实际上，在发送者Actor 对象和接收者Actor 对象之间还存在一个间接处理层——邮箱（消息缓存单元）。即便如此，我们还是将这种消息传输方式称为直接传输方式，因为编程模型提供了一种宝贵的抽象，该抽象使消息就像直接从一个Actor 对象传输到另一个Actor 对象一样。</p>
<p><strong>■ 状态机：</strong> Actor 模型支持有限状态机。当Actor 对象转换为某个预设状态时，就能够改变对未来接收到的信息的处理模式。通过变为另一种消息处理器，Actor 对象就成了一种有限状态机。</p>
<p><strong>■ 无共享：</strong> 一个Actor 对象不会与其他Actor 对象或相关组件共享可变状态</p>
<p><strong>■ 无锁的并发处理方式：</strong> 因为Actor 对象不会共享它们的可变状态，而且它们在同一时刻仅会接收一条消息，所以在对消息做出回应前，Actor 对象永远都不需要尝试锁定它们的状态。因为无须使用锁策略，所以它们能够将多核CPU 从锁定问题中解放出来，集中精力提高吞吐量，并且使所有处理响应式组件的线程不被阻塞。</p>
<p><strong>■ 并行性：</strong> 并发处理方式和并行处理方式是不同的概念。并发处理方式是指多个计算操作同时出现。并行处理方式是指以并发处理方式完成单个目标。并行性是通过将单个的复杂处理过程拆分成较小的任务并以并发处理方式执行它们实现的。当等级较高的Actor 对象能够将多个任务分派给多个下级Actor 对象，或者任务中含有复杂的处理层级时，就适合通过Actor 模型使用并行处理方式。</p>
<p><strong>■ Actor 对象的系统性：</strong> 单个Actor 对象不具备并行性。Actor 对象的量级非常轻，因此在单个系统中创建许多Actor 对象是受推荐的处理方式。任何问题都可以通过添加Actor 对象来解决。</p>
<p><strong>■ 位置透明性：</strong> 使用抽象引用代表Actor 对象的地址。如果Actor 对象A1获得了Actor 对象A2 的引用，Actor 对象A1 就能够向Actor 对象A2 发送消息。提供支持的Actor 系统会负责处理传送消息的操作，不论Actor对象A2 是位于本地Actor 系统还是位于远程Actor 系统中。</p>
<p><strong>■ 监督：</strong> 在Actor 对象之间建立依赖关系，父Actor 对象监督子（下级）Actor 对象。当监督者Actor 对象向下级Actor 对象分派任务时，就必须对这些下级Actor 对象出现的失效情况做出回应。合法的回应包括继续运行、重启和停止下级Actor 对象。监督者还可以通过使本身失效从而使失效情况升级，这会将失效控制权上交给监督者的父对象（监督者的监督者）。监督机制适于在并行处理方式中使用，在该方式中监督者会将多个任务分派给多个下级对象，从而形成任务处理层级。</p>
<p>作为一种计算实体，Actor 对象与原子类似。在有可用线程的情况下，每个Actor 对象都会在收到消息时处理这条消息并且在同一时刻仅能处理一条消息，Actor 对象的性能完全由其本身的吞吐量决定，因此可以说，Actor 对象是按照自己的节奏在工作。然而，因为Actor 对象不会与其他Actor 对象共享可变状态，所以当通过计算或数据处理操作处理收到的消息时，Actor 对象也不必锁定系统资源。</p>
<p><img src="image_1.png" alt="image_1"></p>
<p><strong><center> 在有可用线程的情况下，每个Actor 对象都会在收到消息时处理这条消息 </center></strong></p>
<p><strong><center>并且在同一时刻仅能处理一条消息</center></strong></p>
<p>在无锁情况下，理论上，Actor 对象的吞吐速度会非常快。即使在某些特殊情况中，如果计算和处理操作比较小、集中和耗时较短，那么通常消息就会以极为迅速的方式被发送、接收和处理。这就使你有可能避免使用阻塞机制和导致阻塞问题的机制（串行设备）。因此，Actor 系统就能够拥有高性能、高吞吐量和低操作延迟。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《响应式架构：消息模式Actor实现与Scala、Akka应用集成》 沃恩.弗农</p>
<p><a href="https://www.infoq.cn/article/Reactive-Systems-Akka-Actors-DomainDrivenDesign">使用Akka的Actor模型和领域驱动设计构建反应式系统-InfoQ</a></p>
<p><a href="https://www.jianshu.com/p/d803e2a7de8e">Actor模型 - 简书 (jianshu.com)</a></p>
]]></content>
      <categories>
        <category>Actor模型</category>
      </categories>
      <tags>
        <tag>Actor模型</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/GameWill.github.io/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>计算机网络已由一种通信基础设施发展成为一种重要的信息服务基础设施。已经像水、电、煤气这些设施一样，成为我们生活中不可或缺的一部分。</p>
</blockquote>
<span id="more"></span>

<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="image.png" alt="image"></p>
<p>因为计算机数据是突发是地出现在传输线路上，当用户正在输入和编辑一份待传输的文件时，用户所占用的通信资源暂时未被利用，该通信资源也不能被其他用户利用，宝贵的通信线路资源白白被浪费。因此计算机网络通常采用分组交换，而不是电路交换。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="image_1.png" alt="image_1"></p>
<p>假设主机H6的用户要给主机H2的用户发送一条消息，通常我们把表示该消息的整块数据称为一个报文。在发送报文之前，先把较长的报文划分称为一个个更小的等长数据段。在每一个数据段前面，加上一些有必要的控制信息组成的首部后，就构成了一个分组，也可简称为“包”，首部称为“包头”。首部中包含了分组的目的地址，否则分组传输路径中的各分组交换机（路由器），就不知道如何转发分组了。分组交换机收到一个分组后，先将分组暂时存储下来，再检查其首部，按照首部中的目的地址进行查表转发，找到合适1的转发接口，通过该接口将分组转发给下一个分组交换机。</p>
<p><img src="image_2.png" alt="image_2"></p>
<p>主机H6将所构造出的各分组依次发送出去，各分组经过途中各分组交换机的存储转发，最终到达主机H2。</p>
<p><img src="image_3.png" alt="image_3"></p>
<p>主机H2收到这些分组后，去掉它们的首部，将个数据端组合还原出原始报文。</p>
<p>分组传输过程中其中两种情况（分组丢失、误码、重复…）</p>
<ol>
<li>各分组从源站到达目的站可以走不同的路径（也就是不同的路由）；</li>
<li>分组乱序（分组到达目的站的顺序不一定与分组在源站的发送顺序相同）。</li>
</ol>
<p><img src="image_4.png" alt="image_4"></p>
<p>发送方所要完成的任务是构造分组和发送分组，路由器（分组交换机）所要完成的任务是缓存分组和转发分组（存储转发），接收方所要完成的任务是接收分组和还原报文。与分组类似，报文交换中的交换结点也采用存储转发方式。但报文交换对报文的大小没有限制，这就要求交换结点需要有较大的缓存空间。报文交换主要用于早起的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。</p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><h3 id="三种交换方式对比"><a href="#三种交换方式对比" class="headerlink" title="三种交换方式对比"></a>三种交换方式对比</h3><p><img src="image_5.png" alt="image_5"></p>
<p>假设A，B，C，D是分组传输路径上所要经过的4个结点交换机，纵坐标为时间，对于电路交换，通信之前要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送结束后，需要释放连接，以归还之前建立连接所占用的通信线路资源。</p>
<p>对于报文交换，可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</p>
<p>对于分组交换，可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各节点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</p>
<p>当使用电路交换时，一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</p>
<p>当使用报文交换时，整个报文需要在各结点交换机上进行存储转发，由于不限制报文的大小，因此需要各结点交换机都具有较大的缓存空间。</p>
<p>当使用分组交换时，构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</p>
<h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单定义：一些互相连接的、自治的计算机集合。</p>
<p>互连：指计算机之间可以通过有线或无线的方式进行数据通信；</p>
<p>自治：指独立的计算机，它有自己的硬件和软件，可以单独运行使用；</p>
<p>集合：指至少需要两台计算机</p>
<p>现阶段较好的定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某以特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p>
<p>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</p>
<p>计算机网络并非专门用来传送数据，而是能够支持很多种的应用。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="image_6.png" alt="image_6"></p>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img src="image_7.png" alt="image_7"></p>
<p><img src="image_8.png" alt="image_8"></p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><img src="image_9.png" alt="image_9"></p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><img src="image_10.png" alt="image_10"></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p><img src="image_11.png" alt="image_11"></p>
<p><img src="image_12.png" alt="image_12"></p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p><img src="image_13.png" alt="image_13"></p>
<h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p><img src="image_14.png" alt="image_14"></p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="image_15.png" alt="image_15"></p>
<h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p><img src="image_16.png" alt="image_16"></p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="常见计算机网络体系结构"><a href="#常见计算机网络体系结构" class="headerlink" title="常见计算机网络体系结构"></a>常见计算机网络体系结构</h3><p><img src="image_17.png" alt="image_17"></p>
<p><img src="image_18.png" alt="image_18"></p>
<h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p><img src="image_19.png" alt="image_19"></p>
<p><img src="image_20.png" alt="image_20"></p>
<p><img src="image_21.png" alt="image_21"></p>
<p><img src="image_22.png" alt="image_22"></p>
<p><img src="image_23.png" alt="image_23"></p>
<p><img src="image_24.png" alt="image_24"></p>
<h3 id="分层思想举例"><a href="#分层思想举例" class="headerlink" title="分层思想举例"></a>分层思想举例</h3><p><img src="image_25.png" alt="image_25"></p>
<p>应用层按HTTP协议的规定，构建一个HTTP请求报文，应用层将HTTP请求报文交付给运输层处理。</p>
<p><img src="image_26.png" alt="image_26"></p>
<p>运输层给HTTP请求报文添加一个TCP首部使之成为TCP报文段，TCP报文段的首部的作用主要是为了区分应用进程以及实现可靠传输。运输层将TCP报文段交付给网络层处理。</p>
<p><img src="image_27.png" alt="image_27"></p>
<p>网络层给TCP报文段添加一个IP首部使之成为IP数据报，IP数据报的首部的作用主要是为了使IP数据报可以再互联网上传输，即被路由器转发。网络层将IP数据报交付给数据链路层处理。</p>
<p><img src="image_28.png" alt="image_28"></p>
<p>数据链路层给IP数据报添加一个首部和一个尾部使之成为帧，以太网帧首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收；以太网帧尾部的作用是为了让目的主机检查所接收到的帧是否有误码。数据链路层将帧交给物理层。</p>
<p><img src="image_29.png" alt="image_29"></p>
<p>物理层将帧看作是比特流，由于N1是以太网，因此物理层会给比特流前面添加前导码，前导码作用是为了让目的主机做好接收帧的准备。物理层将添加有前导码的比特流，变换成相应的信号发送到传输媒体，信号通过传输媒体到达路由器。</p>
<p><img src="image_30.png" alt="image_30"></p>
<p>路由器物理层将信号变换为比特流，去掉前导码后，将其交付给数据链路层。</p>
<p><img src="image_31.png" alt="image_31"></p>
<p>数据链路层将帧的首部和尾部去掉后，将其交付给网络层。</p>
<p><img src="image_32.png" alt="image_32"></p>
<p>网络层解析IP数据报的首部，从中提取出目的网络地址，然后查找自身的路由表，确定转发端口，以便进行转发，网络层将IP数据报交付给数据链路层。</p>
<p><img src="image_33.png" alt="image_33"></p>
<p>数据链路层给IP数据报添加一个首部和一个尾部使之成为帧。数据链路层将帧交付给物理层。</p>
<p><img src="image_34.png" alt="image_34"></p>
<p>物理层将帧看做是比特流，由于N2是以太网，因此物理层会给比特流前面添加前导码，物理层将添加有前导码的比特流，变换成相应的信号发送到传输媒体。信号通过传输媒体到达web服务器。</p>
<p><img src="image_35.png" alt="image_35"></p>
<p>web服务器物理层将信号变换为比特流，去掉前导码后，将其交付给数据链路层。</p>
<p><img src="image_36.png" alt="image_36"></p>
<p>数据链路层将帧的首部和尾部去掉后，将其交付给网络层。</p>
<p><img src="image_37.png" alt="image_37"></p>
<p>网络层将IP数据报的首部去掉后，将其交付给运输层。</p>
<p><img src="image_38.png" alt="image_38"></p>
<p>运输层将TCP报文段的首部去掉后，将其交付给应用层。</p>
<p><img src="image_39.png" alt="image_39"></p>
<p>应用层对HTTP请求报文进行解析，然后给主机发回HTTP响应报文。</p>
<p><img src="image_40.png" alt="image_40"></p>
<p>与之前的过程类似，HTTP响应报文需要在Web服务器层层封装，然后通过物理层换成相应的信号，再通过传输媒体传输到路由器。路由器转发该响应报文给主机。主机通过物理层将收到的信号转换成比特流。之后通过逐层解封，最终取出HTTP响应报文。</p>
<h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p><img src="image_41.png" alt="image_41"></p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p><img src="image_42.png" alt="image_42"></p>
<p>协议三要素：语法、语义、同步</p>
<p>语法： 定义所交换信息的格式（定义了所交换信息由哪些字段以及顺序构成）</p>
<p><img src="image_43.png" alt="image_43"></p>
<p>语义：定义收发双方所要完成的操作</p>
<p>HTTP语义规定：主机要访问远程Web服务器，它会构建一个HTTP的Get请求报文，然后将其发送给Web服务器。Web服务器收到该报文并进行解析，知道这是一个HTTP的GET请求报文。于是就在自身内部查找所请求的内容， 并将所找到的内容封装在一个HTTP响应报文中发回给主机。主机收到HTTP响应报文后，对其进行解析，取出所请求的内容并由浏览器解析显示。</p>
<p>同步：定义收发双发的时序关系</p>
<p><img src="image_44.png" alt="image_44"></p>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p><img src="image_45.png" alt="image_45"></p>
<p><img src="image_46.png" alt="image_46"></p>
<p><img src="image_47.png" alt="image_47"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1x4411d7HU?p=6&spm_id_from=pageDriver">计算机网络微课堂（有字幕有背景音乐版）_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>概述</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算机网络概述</tag>
      </tags>
  </entry>
  <entry>
    <title>运输层</title>
    <url>/GameWill.github.io/2021/12/18/%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。</p>
</blockquote>
<span id="more"></span>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>物理层、数据链路层以及网络层它们共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信。但实际上在计算机网络中进行通信的真正实体是位于通信两端主机中的进程。如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议。</p>
<p><img src="image/image.png" alt="image"></p>
<p>运输层向高层用户屏蔽下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在另个运输层实体之间有一条端到端的逻辑通信信道。根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。</p>
<p><img src="image/image_1.png" alt="image_1"></p>
<h1 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h1><p><img src="image/image_2.png" alt="image_2"></p>
<p>发送方的某些应用进程所发送的不同应用报文，在运输层使用UDP协议进行封装，称为UDP复用；而另一些应用进程所发送的不同应用报文，在运输层使用使用TCP协议进行封装，这称为TCP复用；运输层使用端口号来区分不同的应用进程；不管是使用运输层的UDP封装成的UDP用户数据报，还是使用TCP协议封装成的TCP报文段，在网络层都需要使用IP协议封装成IP数据报，称为IP复用。</p>
<p>IP数据报首部中协议字段的值，用来表明IP数据报的数据载荷部分，封装的是何种协议数据单元。取值为6表示封装的是TCP报文段；取值为17表示封装的是UDP用户数据报。</p>
<p>接收方的网络层收到IP数据报后进行IP分用。若IP数据报首部中协议字段的值为17，则把IP数据报的数据载荷部分所封装的UDP用户数据报上交运输层UDP；若协议字段值为6，则把IP数据报的数据载荷部分所封装的TCP报文段上交运输层的TCP。运输层对UDP用户数据报进行UDP分用，对TCP报文段进行TCP分用。也就是根据端口号，将它们交付给上层相应的应用进程。</p>
<h1 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>运行在计算机上的进程使用进程标识符PID来标志。因特网上的计算机并不是使用统一的操作系统，不同的操作系统（Windows,Linux,Mac OS）又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法对TCP/IP体系的应用进程进行标识。</p>
<p>TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程；端口号使用16比特标识，取值范围0~65535。</p>
<ol>
<li>熟知端口号：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20,HTTP使用80，DNS使用53.</li>
<li>登记端口号：1024~49151，为煤油熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如：Microsoft RDP微软远程桌面使用的端口号是3389.</li>
<li>短暂端口号：49152~65535，留给客户端进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ol>
<p>端口号只具有本地意义，即端口号只是为了表示计算机应用层中的个进程，在因特网中，不同计算机中的相同端口号是没有联系的。</p>
<p><img src="image/image_3.png" alt="image_3"></p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="image/image_4.png" alt="image_4"></p>
<p>用户PC，DNS服务器，Web服务器通过交换机进行互联，他们处于同一个以太网中。假设这是Web服务器的域名，DNS服务器中记录有该域名所对应的IP地址。我们在用户PC中使用网页浏览器访问Web服务器的内容。在网页浏览器的地址栏中输入Web服务器域名，用户PC中的DNS客户端进程会发送一个DDNS查询请求报文，其内容为(域名所对应的IP地址是什么？),DNS查询请求报文需要使用运输层的UDP协议，封装成UDP用户数据报，其首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程，例如49152。目的端口字段的值设置为53（DNS服务器端进程所使用的熟知端口号）。</p>
<p><img src="image/image_5.png" alt="image_5"></p>
<p>之后将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器，DNS服务器收到该数据报后，从中解封出UDP用户数据报。UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文交付给本服务器中的DNS服务器端进程。DNS服务器端进程解析DNS查询请求报文内容，然后按其要求查找对应的IP地址。之后，会给用户PC发送DNS响应报文，其内容为(域名所对应的IP地址是192.168.0.3)。DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报，其首部中源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报；目的端口字段的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号。</p>
<p><img src="image/image_6.png" alt="image_6"></p>
<p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC。用户PC收到该数据报后，从中解封出UDP用户数据报。UDP首部汇总的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分也就是DNS响应报文交付给用户PC中的DNS客户端进程。DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名所对应的IP地址为192.168.0.3。</p>
<p><img src="image/image_7.png" alt="image_7"></p>
<p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文了。其内容为“首页内容是什么？”HTTP请求报文需要使用运输层的TCP协议封装成TCP报文段，其首部中的源端口字段的值在短暂端口号49151~65535中挑选一个未被占用的，用来表示HTTP客户端进程。例如仍然使用之前用过的49152.目的端口字段的值设置为80，这是HTTP服务器端进程所使用的熟知端口号。</p>
<p><img src="image/image_8.png" alt="image_8"></p>
<p>之后，将TCP报文段封装在IP数据报中，通过以太网发送给Web服务器。Web服务器收到该数据报后，从中解封出TCP报文段。TCP首部中的目的端口号为80，这表明应该将TCP报文段的数据载荷部分，也就是HTTP请求报文交付给本服务器中的HTTP服务端进程。HTTP服务器端进程解析HTTP请求报文的内容，然后按其要求查找首页内容。之后，会给用户PC发送HTTP响应报文，其内容是HTTP客户端所请求的首页内容。HTTP响应报文需要使用运输层的TCP协议封装成TCP报文段，其首部中的源端口字段的值设置为熟知端口号80，表明这是HTTP服务端进程所发送的TCP报文段；目的端口字段的值设置为49152，这是之前用户PC中发送HTTP请求报文的HTTP客户端进程，所使用的短暂端口号。</p>
<p><img src="image/image_9.png" alt="image_9"></p>
<p>之后将TCP报文段封装在IP数据报中通过以太网发送给用户PC。用户PC收到数据报后，从中解封出TCP报文段。TCP首部中的目的端口号为49152，这表明应将该TCP报文段的数据载荷部分也就是HTTP响应报文交付给用户PC中的HTTP客户端进程。HTTP客户端进程解析HTTP响应报文的内容，并在网页流浪器进行显示。</p>
<h1 id="UDP和TCP对比"><a href="#UDP和TCP对比" class="headerlink" title="UDP和TCP对比"></a>UDP和TCP对比</h1><ol>
<li>UDP无连接；TCP面向连接</li>
</ol>
<p><img src="image/image_10.png" alt="image_10"></p>
<p>使用UDP的通信双方，可以随时发送数据；使用TCP的通信双方，在进行数据传输之前，必须使用“三报文握手”来建立TCP连接。TCP连接建立成功后才能进行数据传输。数据传输结束后，必须使用“四报文挥手”来释放TCP连接。</p>
<ol start="2">
<li>UDP支持单播、多播以及广播；TCP支持单播</li>
</ol>
<p><img src="image/image_11.png" alt="image_11"></p>
<ol start="3">
<li>UDP面向应用报文；TCP面向字节流</li>
</ol>
<p><img src="image/image_12.png" alt="image_12"></p>
<p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界；发送方的TCP把应用进程交付下来的数据块仅仅看做是一连串的、无结构的字节流，TCP并不知道这些待传送的字节流的含义，仅将它们编号并存储在自己的发送缓存中。TCP根据发送策略从发送缓存中提取一定数量的字节，构建TCP报文段并发送。接收方的TCP一方面从接收到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程。TCP不保证接收方应用进程所收到的数据块与发送方应用进程</p>
<p>所发出的数据块具有对应大小的关系。但接收方应用进程收到的字节流必须和发送方应用进程发出的字节流完全一样。也就是说TCP是面向字节流的，这正是TCP实现可靠传输、流量控制以及拥塞控制的基础。</p>
<ol start="4">
<li>UDP向上层提供无连接不可靠传输服务；TCP向上层提供面向连接的可靠传输服务</li>
</ol>
<p><img src="image/image_13.png" alt="image_13"></p>
<p>发送方给接收方发送UDP用户数据报，若传输过程中用户数据报受到干扰而产生误码，接收方UDP可以通过该数据报首部中的校验和字段的值检查出产生误码的情况。但仅仅丢弃该数据报，其他什么也不做。发送方给接收方发送UDP数据报，如果该数据报被因特网中的某个路由器丢弃了，发送方UDP不做任何处理，因为UDP向上层提供的是无连接不可靠的传输服务。因此UDP用户数据报出现的误码和丢失等问题，UDP并不关心。基于UDP这个特点，UDP适用于实时应用，例如IP电话、视频会议等。</p>
<p>尽管网际层中的IP协议向上层提供的是无连接不可靠的传输服务。也就是说，IP数据报可能在传输过程中出现丢失或误码。但只要运输层使用TCP协议，就可向其上层提供面向连接的可靠传输服务。使用TCP协议的收发双方基于TCP连接的可靠信道进行数据传输。不会出现误码、丢失、乱序以及重复等传输差错。</p>
<p>TCP适用要求可靠传输的应用，例如文件传输等。</p>
<ol start="5">
<li>UDP用户数据报首部仅8个字节；TCP报文首部最小20字节最大60字节</li>
</ol>
<p><img src="image/image_14.png" alt="image_14"></p>
<p>一个UDP用户数据报由首部和数据载荷两部分构成。首部仅有4个字段，每个字段长度为2个字节。由于UDP不提供可靠传输服务，它仅仅在网际层的基础上，添加了用于区分应用进程的端口；</p>
<p>一个TCP报文段由首部和数据载荷两部分构成，首部其最小长度为20字节，最大60字节，这是因为TCP要实现可靠传输、流量控制、拥塞控制等服务。</p>
<h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p><img src="image/image_15.png" alt="image_15"></p>
<p>假设主机A和B是因特网上的两台主机，它们之间已经建立了TCP连接，A给B发送数据，B对A进行流量控制。假设主机A发送的每个TCP数据报文段可携带100字节数据。因此图中每个小个子表示100个字节数据的序号。在主机A和B建立TCP连接时，B告诉A：“我的接收窗口为400”。因此，主机A将自己的发送窗口也设置为400。这意味着主机A在未收到主机B发来的确认时，可将序号落入发送窗口中的全部数据发送出去。</p>
<p>主机A将发送窗口内序号1~100的数据封装成一个TCP报文段发送出去。发送窗口内容还有300字节可以发送。seq是TCP报文段首部中的序号字段，取值1表示TCP报文段数据载荷的第一个字节的序号是1.</p>
<p>DATA表示TCP数据报文段。主机A将发送窗口内序号101<del>200的数据封装成一个TCP报文段发送出去。发送窗口内还有200字节可以发送。主机A将发送窗口内序号201</del>300的数据封装成一个TCP报文段发送出去。但该报文段在传输过程中丢失了，主机A发送窗口内还有100字节可以发送。主机B对主机A所发送的201号以前的数据进行累计确认。并在该可累计确认中将窗口字段的值调整为300，也就是对主机A进行流量控制。ACK是TCP报文段首部中的标志位，取值1表示这是一个TCP确认报文段。ack是TCP报文段首部中的确认号字段，取值201表示序号201之前的数据已全部正确接收，现在希望收到序号201及其后续数据。rwnd是TCP报文段首部中的窗口字段，取值300表示自己的接收窗口大小为300.</p>
<p><img src="image/image_16.png" alt="image_16"></p>
<p>主机A收到该累计确认后，将发送窗口向前滑动，使已发送并确认的这些数据的序号移出发送窗口。由于主机B在该累计确认中将自己的接收窗口调整为了300。因此主机A相应地将自己的发送窗口调整为300.</p>
<p>目前主机A发送的序号为201<del>500，也就是主机A还可以发送这300字节。其中201</del>300号字节是已发送的数据，若重传计时器超时，它们会被重传。301<del>400号字节以及401</del>500号字节还未被发送。可被分别封装在一个TCP报文段中发送。主机A现在可发送缓存中序号1~200的字节数据全部删除了，因为已经收到了主机B对它们的累计确认。</p>
<p><img src="image/image_17.png" alt="image_17"></p>
<p>主机A将发送窗口内序号301<del>400的数据封装成一个TCP报文段发送出去。发送窗口内容还有100字节可以发送。主机A将发送窗口内序号401</del>500的数据封装成一个TCP报文段发送出去。至此，序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了。</p>
<p><img src="image/image_18.png" alt="image_18"></p>
<p>现在发送窗口内序号201~300这100个字节数据的重传计时器超时了。主机A将它们重新封装成一个TCP报文段发送出去。暂时不能发送其他数据。主机B收到该重传的TCP报文段后，对主机A所发送的501号以前的数据进行累计确认。并在该累计确认中将窗口字段的值调整为100，这是主机B对主机A进行的第二次流量控制。</p>
<p><img src="image/image_19.png" alt="image_19"></p>
<p>主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移出发送窗口。由于主机B在该累计确认中将自己的接收串口调整为了100.因此主机A相应地将自己的发送窗口调整为100.目前主机A发送窗口内容的序号为501<del>600.也就是主机A还可以发送这100字节。主机A现在可将发送缓存中序号201</del>500的字节数据全部删除了，因为已经收到了主机B对它们的累计确认。主机A将发送窗口内序号501~600的数据封装成一个TCP报文段发送出去。至此序号落在发送窗口内的数据全部发送出去了，不能再发送新数据了。主机A所发送的601号以前的数据进行累计确认。并在该累计确认中将窗口字段的值调整为0，这是主机B对主机A进行的第三次流量控制。</p>
<p><img src="image/image_20.png" alt="image_20"></p>
<p>主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据序号移出发送窗口。由于主机B在该累计确认中将自己的接收窗口调整了0。因此主机A相应地将自己的发送窗口调整为0.目前，主机A不能再发送一般的TCP报文段了。主机A现在可将发送缓存中序号501~600的字节数据全部删除了，因为已经收到了主机B对它们的累计确认。</p>
<p><img src="image/image_21.png" alt="image_21"></p>
<p>假设主机B向主机A发送了零窗口的报文段后不久，主机B的接收缓存又有了一些存储空间。于是，主机B向主机A发送了接收窗口等于300的报文段，然而这个报文段在传输过程中丢失了。主机A一直等待主机B发送的非零窗口的通知，主机B也一直等待主机A发送的数据。</p>
<p>如果不采取措施，这种互相等待而形成的死锁局面将一直持续下去，为了解决这个问题TCP为每一个连接设有一个持续计时器，只要TCP连接的一放收到对方的零窗口通知，就启动持续及时器。若持续计时器超时，就发送一个零窗口探测报文，仅携带一字节的数据。而对方在确认这个探测报文段时，给出自己现在的接收窗口值。如果接收窗口仍然为0，那么收到这个报文段的一方就重新启动持续及时器；如果接收窗口不是0，那么死锁的局面就可以被打破了。 </p>
<p>在本例中，主机A收到零窗口通知时，就启动一个持续计时器。当持续计时器超时，主机A立刻发送一个仅携带一字节数据的零窗口探测报文段。假设主机B此时的接收窗口又为0了，主机B就在确认这个零窗口探测报文段时，给出自己现在的接收窗口值为0。主机A再次受到零窗口通知，就再次启动一个持续计时器。当持续计时器超时，主机A立刻发送一个零窗口探测报文段。假设主机B此时的接收缓存又有一些存储空间，于是将自己的接收窗口调整为了300，主机B就在确认这个零窗口探测报文段时给出自己现在的接收窗口值为300.这样就打破了死锁的局面。</p>
<p>TCP规定即使接收窗口为0，也必须接收零窗口探测报文段、确认报文段以及携带有紧急数据的报文段。如果零窗口报文段丢失也可打破死锁局面，因为零窗口报文段也有重传计时器，当重传计时器超时后，零窗口报文段会被重传。</p>
<p><img src="image/image_22.png" alt="image_22"></p>
<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种强开就叫做拥塞。若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷增大而下降。</p>
<blockquote>
<p>网络的资源：在计算机网络中的链路容量（即宽带）、交换结点中的缓存和处理机等，都是网络的资源。</p>
</blockquote>
<p><img src="image/image_23.png" alt="image_23"></p>
<p>输入负载代表单位时间内输入给网络的分组数量；吞吐量代表单位时间内网络输出的分组数量。具有理想拥塞控制的网络，在吞吐量达到饱和之前，网络吞吐量应等于所输入的负载，故吞吐量曲线是45度的斜线。但当输入负载超过某一限度时，由于网络资源受限吞吐量就不再增长而保持水平线（即吞吐量达到饱和），这就表明输入的负载中有一部分损失掉了。然而实际的网络情况，随着输入负载的增大，网络吞吐量的增长率逐渐减小，也就是在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了；当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了轻度拥塞的状态。当输入负载到达某一数值时，网络的吞吐量反而随输入负载的增大而减小，这时网络就进入了拥塞状态。当输入负载继续增大到某一数值时，网络的吞吐量就减小为0，此时网络就无法工作了（死锁）。因此进行拥塞控制是十分必要的，实际的拥塞控制应该尽量接近理想的拥塞控制曲线。</p>
<h2 id="四种拥塞控制算法"><a href="#四种拥塞控制算法" class="headerlink" title="四种拥塞控制算法"></a>四种拥塞控制算法</h2><p>举例假定如下条件：</p>
<ol>
<li>数据是单方向传送，而另一个方向只传送确认</li>
<li>接收方总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定。</li>
<li>以最大报文段MSS的个数为讨论问题的单位，而不是以字节为单位。</li>
</ol>
<h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p><img src="image/image_24.png" alt="image_24"></p>
<p><img src="image/image_25.png" alt="image_25"></p>
<p>TCP发送方一开始使用慢开始算法，让拥塞窗口值从1开始按指数规律增大。当拥塞窗口值增大到慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大。当发生超时重传时，就判断网络很可能出现了拥塞。采取相应措施，一方面将慢开始门限值更新为发生拥塞窗口值的一半；另一方面将拥塞窗口值减少为1，并重新开始执行慢开始算法。拥塞窗口值又从1开始按指数规律增大。当增大到了新的慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大。</p>
<p>慢开始是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢；</p>
<p>拥塞避免并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>慢开始和拥塞避免算法是1988年提出的TCP拥塞控制算法。1990年又增加了两个新的拥塞控制算法（改进TCP的性能），这就是快重传和恢复。有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞；这将导致发送方超时重传，并误认为网络发生了拥塞；发送方把拥塞窗口cwnd又设置为最小值1，并错误地启动慢开始算法，因而降低了传输效率。</p>
<p><img src="image/image_26.png" alt="image_26"></p>
<p>所谓快重传就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</p>
<ol>
<li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；</li>
<li>及时收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li>
<li>发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。</li>
<li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。使用快重传可以使整个网络的吞吐量提高约为20%。</li>
</ol>
<p><img src="image/image_27.png" alt="image_27"></p>
<p>发送方发送1号数据报文段，接收方收到后给发送方发回对1号报文段的确认。在该确认报文段到达发送方之前，发送方还可以将发送窗口内的2号数据报文段发送出去。接收方收到后给发送方发回对2号报文段的确认。在该确认报文段到达发送方之前，发送方还可以将发送窗口内的3号数据报文段发送出去，但该报文段丢失了，接收方自然不会给发送方发回针对该报文段的确认。发送方还可以将发送窗口内的4好数据报文段发送出去。接收方收到后发现这不是按序到达的报文段，因此给发送方发回针对2号报文段的重复确认（表明我现在希望收到的是3号报文段，但是我没有收到3号报文段，而是收到了未按序到达的报文段）。发送方还可以将发送窗口内的5号数据报文段发送出去，接收方收到后发现不是按序到达的报文段，因此给发送方发回针对2号报文段的重复确认。发送方还可以将发送窗口内的6号数据报文段发送出去。接收方收到后发现不是按序到达报文段，因此给发送方发回针对2号报文段的重复确认。至此发送方会收到3个连续的对2号报文段的重复确认就立即重传3号报文段，接收方收到后，给发送方发回针对6号报文段的确认，这样就不会造成对3号报文段的超时重传，而是提早进行了重传。</p>
<h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而是执行快恢复算法；发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；开始执行拥塞避免算法。也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值在增大一些，即等于新的ssthresh+3.</p>
<ol>
<li>既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络；</li>
<li>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；</li>
<li>可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。</li>
</ol>
<h2 id="结合四种拥塞算法举例"><a href="#结合四种拥塞算法举例" class="headerlink" title="结合四种拥塞算法举例"></a>结合四种拥塞算法举例</h2><p><img src="image/image_28.png" alt="image_28"></p>
<p>TCP发送方一开始使用慢开始算法，让拥塞窗口值从1开始按指数规律增大。当拥塞窗口值增大到慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大。当发生超时重传时，就判断网络很可能出现了拥塞。采取相应措施，一方面将慢开始门限值更新为发生拥塞窗口值的一半；另一方面将拥塞窗口值减少为1，并重新开始执行慢开始算法。拥塞窗口值又从1开始按指数规律增大。当增大到了新的慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大。</p>
<p>当发送方收到3个重复确认时，就进行快重传和快恢复（更新慢开始门限值为当前拥塞窗口值的一半，并将拥塞窗口值也取值为新的慢开始门限值，转而执行拥塞避免算法，让拥塞窗口值按线性加1的规律增大）。</p>
<p><img src="image/image_29.png" alt="image_29"></p>
<h1 id="超时重传时间选择"><a href="#超时重传时间选择" class="headerlink" title="超时重传时间选择"></a>超时重传时间选择</h1><h2 id="问题举例"><a href="#问题举例" class="headerlink" title="问题举例"></a>问题举例</h2><h3 id="问题举例一"><a href="#问题举例一" class="headerlink" title="问题举例一"></a>问题举例一</h3><p><img src="image/image_30.png" alt="image_30"></p>
<p>假设主机A和B是因特网上的两台主机，它们之间已经建立了TCP连接。纵坐标为时间，主机A给主机B发送TCP数据报文段0并记录下当前的时间。主机B收到后，给主机A发送相应的确认报文段。主机A收到确认报文段后，记录下当前的时间。主机A记录下的两个时间的差值就是报文段往返时间RTT0。</p>
<p>如果超时重传时间RTO的值设置的比RTT0的值小，会引起报文段不必要的重传，使网络负荷增大；</p>
<p><img src="image/image_31.png" alt="image_31"></p>
<p>如果将超时重传时间RTO的值设置的远大于RTT0的值，会使重传推迟时间太长，导致网络的空闲时间增大，降低了传输效率。因此，超时重传时间RTO的值应略大于往返时间RTT。</p>
<p><img src="image/image_32.png" alt="image_32"></p>
<p>往返时间RTT1远大于RTT0，如果超时重传时间RTO，还是我们之前所确定的略大于RTT0的话，这对于数据报文段1是不合适的，会造成该报文段不必要的重传。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO。</li>
<li>利用每次测量得到的RTT样本，计算加权平均往返时间RTTs（平滑的往返时间）<br>  RTTs1 = RTT1<br>  新的RTTs = （1-α）x 旧的RTTs + α x 新的RTT样本（0 ≤ α &lt;1）<br>  若α很接近0，则新RTT样本对RTTs的影响不大；<br>  若α很接近1，则新的RTT样本对RTTs的影响较大；<br>  已成为标准的RFC6298推荐α值为1/8，即0，125.</li>
<li>超时重传时间RTO应略大于加权平均往返时间RTTs。</li>
</ul>
<p><img src="image/image_33.png" alt="image_33"></p>
<h3 id="问题举例二"><a href="#问题举例二" class="headerlink" title="问题举例二"></a>问题举例二</h3><p><img src="image/image_34.png" alt="image_34"></p>
<p>情况一：主机A给主机B发送TCP数据报文段，但该报文段在传输过程中丢失了。当超时重传及时器超时后，主机A就重传该报文段，主机B收到后，给主机A发送确认报文段。但主机A收到确认报文段后，无法判断报文段是对原报文段的确认还是对重传报文段的确认。源主机若误将确认当作是对原报文段的确认：所计算出的RTTs和RTO就会偏大，降低了传输效率。</p>
<p>情况二：主机A给主机B发送TCP数据报文段，主机B收到后，给主机A发送确认报文段。由于某种原因，该确认报文段没有在正常时间内到达主机A，这必然会导致主机A对之前所发送的数据报文段的超时重传。主机A收到迟到的确认报文段后，无法判断该报文段是对原报文段的确认，还是对重传报文段的确认。源主机若误将确认当做是对重传报文段的确认，所计算出的RTTs和RTO就会偏小，导致报文段没必要的重传，增大网络负荷。</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>针对出现超时重传时无法推测往返时间RTT的问题，Karn提出了一个算法：在计算加权平均往返时间RTTs时，只要报文段重传了，就不采用其往返时间RTT样本。也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。da</p>
<p>但这会引起新的问题：报文段的时延突然增大了很多，并且之后很长一段时间都保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新，会导致报文段反复被重传。</p>
<p>因此，对Karn算法进行修正：报文段每重传一次，就把超时重传时间RTO增大一些。如将新RTO的值取为旧RTO值的2倍。</p>
<h2 id="举例超时重传计算"><a href="#举例超时重传计算" class="headerlink" title="举例超时重传计算"></a>举例超时重传计算</h2><p><img src="image/image_35.png" alt="image_35"></p>
<h1 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h1><p>TCP基于以字节为而单位的滑动窗口来实现可靠传输。</p>
<h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><p><img src="image/image_36.png" alt="image_36"></p>
<p>发送方待发送数据字节的序号。</p>
<p><img src="image/image_37.png" alt="image_37"></p>
<p>在报文段首部中的窗口字段的值为20，也就是接收方表明自己的接收窗口的尺寸为20字节。确认号字段的值为31，这表明接收方希望收到下一个数据的序号是31，而序号30为止的数据已经全部正确接收了。因此发送方根据这两个字段的值构造出自己的发送窗口。</p>
<p><img src="image/image_38.png" alt="image_38"></p>
<p>接收方告诉发送方自己的接收窗口尺寸为20，因此发送方将自己的发送窗口尺寸也设置为20.发送方在没有收到接收方确认的情况下，可以把发送窗口内的数据一次全部发送出去，凡是已经发送过的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用。</p>
<p><img src="image/image_39.png" alt="image_39"></p>
<p>假定发送方将发送窗口内序号31<del>41的数据封装在几个不同的报文段中发送出去，此时发送窗口的位置并没有改变。发送窗口内31</del>41的数据已经发送但未收到确认，而序号42~50的数据是允许发送但未发送的。</p>
<p><img src="image/image_40.png" alt="image_40"></p>
<p>假设发送方之前发送的封装有32和33号数据的报文段到达了接收方，由于数据序号落在接收窗口内，所以接收方接受它们，并将它们存入缓存。但是它们是未按序到达的数据，因为31号数据还没有到达，这有可能是丢了或者滞留在网络中的某处。</p>
<p><img src="image/image_41.png" alt="image_41"></p>
<p>接收方只能对按序收到的数据中最高序号给出确认，因此接收方发出的确认报文段中的确认序号仍然是31。发送方收到该确认报文段后，发现这是一个针对31号数据的重复确认，就知道接收方收到了未按序到达的数据。由于这是针对31号数据的第一个重复确认，因此这并不会引起发送方针对该数据的快重传。另外，接收方通知得到窗口尺寸仍是20，因此发送方仍保持自己的发送窗口尺寸为20.</p>
<p><img src="image/image_42.png" alt="image_42"></p>
<p>现在假设封装有31号数据的报文段到达了接收方，接收方接受该报文段。</p>
<p><img src="image/image_43.png" alt="image_43"></p>
<p>将其封装的31号数据存入接收缓存。接收方现在可将接收到的31~33号数据交付给应用进程。</p>
<p><img src="image/image_44.png" alt="image_44"></p>
<p>然后将接收窗口向前移动3个序号，并给发送方发送确认报文段，确认报文段中窗口字段的值为20，确认号字段的值为34.</p>
<p><img src="image/image_45.png" alt="image_45"></p>
<p>现在，假设又有几个数据报文段到达了接收方，它们封装有37，38以及40号数据。这些数据的序号虽然落在接收窗口内，但它们都是未按序到达的数据，只能先暂存在接收缓存中。</p>
<p><img src="image/image_46.png" alt="image_46"></p>
<p>假设接收方先前发送的确认报文段到达了发送方。发送方接收后，将发送窗口向前滑动3个序号，这样有新序号52<del>53落入发送窗口内。发送方继续将发送窗口内序号42</del>53的数据封装在几个不同的报文段中发送出去。现在，至此窗口内的序号已经用完了，发送方在未收到接收方发来确认的情况下，不能再发送新得到数据。序号落在发送窗口内的已发送数据，如果迟迟收不到接收方的确认，则会产生超时重传。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接收窗口一样大。<br>  网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。<br>  发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。</li>
<li>对于不按序到达的数据应如何处理，TCP并无明确规定。<br>  如果接收方把不按序到达的数据一律丢失，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据。<br>  TCP通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中缺少的字节收到后，再按序交付上层的应用进程。</li>
<li>TCP要求接收方必须有累计确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便带上。<br>  接收方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认【RFC 1122】。<br>  捎带确认实际上并不经常发生，因为大多数应用程序很好同时在两个方向上发送数据。</li>
<li>TCP的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。</li>
</ul>
<p><img src="image/image_47.png" alt="image_47"></p>
<p><img src="image/image_48.png" alt="image_48"></p>
<h1 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h1><h2 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h2><ul>
<li>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</li>
<li>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</li>
<li>TCP的运输连接管理就是使运输连接的建立和释放都能正常地进行。</li>
<li>TCP运输连接有三个阶段:建立TCP连接、数据传送和释放TCP连接。</li>
</ul>
<p><img src="image/image_49.png" alt="image_49"></p>
<ul>
<li>TCP的连接建立要解决以下三个问题：</li>
</ul>
<ol>
<li>使TCP双方能够确认对方的存在；</li>
<li>使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</li>
<li>使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li>
</ol>
<ul>
<li>TCP使用“三报文握手”建立连接</li>
</ul>
<p><img src="image/image_50.png" alt="image_50"></p>
<p>其中一台主机中的某个应用进程主动发起TCP连接建立，称为TCP客户；另一台主机中被动等待TCP连接建立的应用进程，称为TCP服务器。“握手”需要在TCP客户和服务器之间交换三个TCP报文段。最初，两端的TCP进程都处于关闭状态。一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息，例如：TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前发送和接收序号等。之后，就准备接受TCP客户进程的连接请求。此时，TCP服务器进程就进入监听状态，等待TCP客户进程的TCP请求。</p>
<p><img src="image/image_51.png" alt="image_51"></p>
<p>TCP服务器进程是被动等待来自TCP客户进程的连接请求，而不是主动发起，因此称为被动打开连接。TCP客户进程也是首先创建传输控制块。</p>
<p><img src="image/image_52.png" alt="image_52"></p>
<p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段并进入同步已发送状态。TCP连接请求报文段首部中的同步位SYN被设置为1，表明这是一个TCP连接请求报文段，序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号。由于TCP连接建立是由TCP客户主动发起的，因此称为主动打开连接。</p>
<blockquote>
<p>TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号。</p>
</blockquote>
<p><img src="image/image_53.png" alt="image_53"></p>
<p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户端进程发送TCP连接请求确认报文段，并进入同步已接收状态。该报文段首部中的同步位SYN和确认位ACK都设置为1，表明这是一个TCP连接请求确认报文段。序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号。确认号字段ack的值被设置成了x+1，这是对TCP客户端进程所选择的初始序号的确认。</p>
<blockquote>
<p>该报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗一个序号。</p>
</blockquote>
<p><img src="image/image_54.png" alt="image_54"></p>
<p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已建立状态。该报文段首部中的确认位ACK被设置为1，表明这是一个普通的TCP确认报文段。序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，并且不携带数据，因此第二个报文段的序号为x+1.确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认。</p>
<blockquote>
<p>TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号。在这种情况下，所发送的下一个数据报文段的序号仍为x+1.</p>
</blockquote>
<p><img src="image/image_55.png" alt="image_55"></p>
<p>TCP服务器进程收到该确认报文段也进入连接已建立状态。现在TCP双方都进入了连接已建立状态。它们可以基于已建立好的TCP连接，进行可靠的数据传输了。</p>
<ul>
<li>能否使用“两报文握手”建立连接？</li>
</ul>
<p><img src="image/image_56.png" alt="image_56"></p>
<p>TCP客户进程发出一个TCP连接请求报文段，但该报文段在某些网络结点长时间滞留了，这必然会造成该报文段的超时重传。假设重传的报文段被TCP服务器进程正常接收。TCP服务器进程给TCP客户进程发送一个TCP连接请求确认报文段，并进入链接已建立状态。TCP客户进程收到TCP连接请求确认报文段后，进入TCP连接已建立状态，但不会给TCP服务器进程发送针对该报文段的普通确认报文段。现在TCP双方都处于连接已建立状态，它们可以相互传输数据，之后，可以通过“四报文挥手”来释放连接，这样TCP双方都进入了关闭状态。</p>
<p><img src="image/image_57.png" alt="image_57"></p>
<p>一段时间后，之前滞留在网络中的那个失效的TCP连接请求报文段到达了TCP服务器进程。TCP服务器进程会误认为这是TCP客户进程，又发起了一个新的TCP连接请求，于是给TCP客户进程发送TCP连接请求确认报文段，并进入连接已建立状态。该报文段到达TCP客户进程，有TCP客户进程并没有发起新的TCP连接请求，并且处于关闭状态，因此不会理会该报文段。但TCP服务器进程已进入连接已建立状态，它认为新的TCP连接已建立好了，并一直等待TCP客户进程发来数据，这将白白浪费TCP服务器进程所在主机的很多资源。</p>
<p>综上所述，采用“三报文握手”而不是“两报文握手”来建立TCP连接，是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误。</p>
<p><img src="image/image_58.png" alt="image_58"></p>
<h2 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h2><p><img src="image/image_59.png" alt="image_59"></p>
<p>数据传输结束后，TCP通信双方都可以释放连接。现在TCP客户进程和TCP服务器进程都处于连接已建立状态。假设使用TCP客户进程的应用进程通知其主动关闭TCP连接，TCP客户进程会发送TCP连接释放报文段并进入终止等待1状态。该报文段首部中的终止为FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认。序号seq的字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1.确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的数据的最后一个字节的序号加1.</p>
<blockquote>
<p>TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号。</p>
</blockquote>
<p><img src="image/image_60.png" alt="image_60"></p>
<p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态。</p>
<p>该报文段首部中的确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段。序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过得数据的最后一个字节的序号加1。这也与之前收到的TCP连接上方报文段中的确认号匹配。确认号ack字段的值设置为u+1,这是对TCP连接释放报文段的确认。</p>
<p><img src="image/image_61.png" alt="image_61"></p>
<p>TCP服务器进程这时应通知高层应用进程：TCP客户进程要断开与自己的TCP连接。此时，从TCP客户进程到TCP服务进程这个方向的连接就释放了。这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了，但TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收。也就是说，从TCP服务器进程到TCP客户进程这个方向的连接并未关闭。</p>
<p><img src="image/image_62.png" alt="image_62"></p>
<p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态。等待TCP服务器进程发出的TCP连接释放报文段。若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接。由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接。</p>
<p><img src="image/image_63.png" alt="image_63"></p>
<p><img src="image/image_64.png" alt="image_64"></p>
<p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态，该报文段首部中的终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认。现在假定序号seq字段的值为w。这是因为在半关闭状态下，TCP服务器进程可能又发送了一些数据。确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认。</p>
<p><img src="image/image_65.png" alt="image_65"></p>
<p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态。该报文段首部中的确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段。序号seq字段的值设置为u+1,这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号。确认好ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认。</p>
<p><img src="image/image_66.png" alt="image_66"></p>
<p>TCP服务器进程收到该报文段后就进入关闭状态。而TCP客户进程还要经过2MSL后才能进入关闭状态。</p>
<blockquote>
<p>MSL（Maximum Segment Lifetime）是最长报文段寿命，RFC793建议为2分钟。</p>
</blockquote>
<ul>
<li>TCP客户进程在发送完最后最后一个确认报文段后，为什么不直接进入关闭状态，而是要进入时间等待状态？</li>
</ul>
<p><img src="image/image_67.png" alt="image_67"></p>
<p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态，TCP客户进程收到TCP连接释放报文段后，发送普通的TCP确认报文段，并进入关闭状态，而不是时间等待状态。然而该TCP确认报文段丢失了，这必然会造成TCP服务器进程对之前所发送的TCP连接释放报文段的超时重传，并仍处于最后确认状态，重传的TCP连接释放报文段到达TCP客户进程，由于TCP客户进程属于关闭状态，因此不理睬该报文段，这必然会造成TCP服务器进程反复重传TCP连接释放该报文段，并一直处于最后确认状态而无法进入关闭状态。</p>
<p>因此，时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态。TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。</p>
<h2 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h2><p>TCP双方已经建立了连接，后来TCP客户进程所在的主机突然出现了故障。TCP服务器进程以后就不能再收到TCP客户进程发来的数据。因此，应当有措施使TCP服务器进程不要再白白等待下去。</p>
<ol>
<li>TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动报活计时器（2小时定时）。</li>
<li>若保活计时器定时周期内未红素到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</li>
</ol>
<h1 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h1><p>为了实现可靠传输，TCP采用了面向字节流的方式。但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为TCP报文段后进行发送。一个TCP报文段由首部和数据载荷两部分构成；TCP的全部功能都体现在它首部中各字段的作用。</p>
<h2 id="源端口和目的端口"><a href="#源端口和目的端口" class="headerlink" title="源端口和目的端口"></a>源端口和目的端口</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="image/image_68.png" alt="image_68"></p>
<p>源端口：占16比特，写入源端口号，用来表示发送该TCP报文段的应用进程。</p>
<p>目的端口：占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程。</p>
<h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><p><img src="image/image_69.png" alt="image_69"></p>
<p>仅从运输层端口号这个角度举例说明，当在浏览器地址栏中输入Web服务器的域名后，浏览器进程会构建一个封装有HTTP请求报文的TCP报文段 ，该报文段首部中的源端口字段会填写一个短暂端口号，例如49152，用来标识发送该报文段的浏览器进程。目的端口号字段会填写熟知端口号80，因为使用HTTP协议的Web服务器进程默认监听该端口。</p>
<p><img src="image/image_70.png" alt="image_70"></p>
<p>Web服务器收到该TCP报文段后，从中解封出HTTP请求报文，并根据TCP报文段首部中目的端口字段的值80，将HTTP请求报文上交给Web服务器进程。</p>
<p><img src="image/image_71.png" alt="image_71"></p>
<p>Web服务器进程根据HTTP请求报文的内容进行相应处理，并构建一个HTTP响应报文，HTTP响应报文需要封装成TCP报文段进行发送。该报文段首部中的源端口字段会填写熟知端口号80，用来标识发送该TCP报文段的Web服务器进程。而目的端口字段会填写49152，这是主机中需要接收该TCP报文段的浏览器进程所对应的端口号。</p>
<p><img src="image/image_72.png" alt="image_72"></p>
<p>主机收到该TCP报文段后，从中解封出HTTP响应报文，并根据TCP报文段首部中目的端口字段的49152，将HTTP响应报文上交给浏览器进程。浏览器进程对HTTP响应报文的内容进行解析并显示。</p>
<h2 id="序号、确认号和ACK"><a href="#序号、确认号和ACK" class="headerlink" title="序号、确认号和ACK"></a>序号、确认号和ACK</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><img src="image/image_73.png" alt="image_73"></p>
<p>序号：占32比特，取值范围[0,2的32次-1]，序号增加到最后一个后，下一个序号就又回到0.指出本TCP报文段的数据载荷的第一个字节的序号。</p>
<p><img src="image/image_74.png" alt="image_74"></p>
<p>例如TCP报文段，由首部和数据载荷两部构成，数据载荷中的每个字节数据都有序号，首部中序号字段应填入的十进制值为166，用来指出数据载荷的第一个字节的序号为166.</p>
<p>确认号：占32比特，取值范围[0,2的32次-1]，确认号增加到最后一个后，下一个确认就又回到0.指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。</p>
<p>若确认号为n，则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。</p>
<p>确认标志位ACK：取值为1时确认号字段才有效；取值为0时确认好字段无效。TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1.</p>
<h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p><img src="image/image_75.png" alt="image_75"></p>
<p>TCP客户进程发送一个TCP报文段，该报文段首部中序号字段的取值为201，这表示该TCP报文段数据载荷的第一个字节的序号为201.假设数据载荷长度为100字节，首部中确认号字段的取值为800，这表示TCP客户进程收到了TCP服务器进程发来的序号到799为止的全部数据，现在期望收到序号从800开始的数据。为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1。</p>
<p><img src="image/image_76.png" alt="image_76"></p>
<p>TCP服务器进程收到该报文段后，也给TCP客户进程发送TCP报文段，该报文段首部中序号字段取值为800，这表示该TCP报文段数据载荷的第一个字节的序号为800，这正好用户TCP客户进程的确认相匹配。假设数据载荷的长度为200字节，首部中确认号字段的取值为301，这表示TCP服务器进程收到了TCP客户进程发来的序号到300为止的全部数据，现在期望收到序号从301开始的数据，为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1。</p>
<h2 id="数据偏移"><a href="#数据偏移" class="headerlink" title="数据偏移"></a>数据偏移</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p><img src="image/image_77.png" alt="image_77"></p>
<p>数据偏移：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际上指出了TCP报文段的首部长度。首部固定长度为20字节，因此数据偏移字段的最小值为二进制0101；首部最大长度为60字节，因此数据偏移字段的最大值为二进制1111（15个长度单位=15<em>32位=15</em>4字节）</p>
<h3 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h3><p><img src="image/image_78.png" alt="image_78"></p>
<h2 id="保留"><a href="#保留" class="headerlink" title="保留"></a>保留</h2><p><img src="image/image_79.png" alt="image_79"></p>
<p>保留：占6比特，保留为今后使用，目前应置为0.</p>
<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p><img src="image/image_80.png" alt="image_80"></p>
<p>窗口：占16比特，以字节为单位。指出发送本报文段的一方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。这是以接收方的接收能力来控制发送方的发送能力，称为流量控制。</p>
<blockquote>
<p>发送窗口的大小还取决于拥塞窗口的大小，也就是应该从接收窗口和拥塞窗口中取小者。</p>
</blockquote>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><p><img src="image/image_81.png" alt="image_81"></p>
<p>校验和：占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和是，要在TCP报文段的前面加上12字节的伪首部。</p>
<h2 id="SYN"><a href="#SYN" class="headerlink" title="SYN"></a>SYN</h2><p><img src="image/image_82.png" alt="image_82"></p>
<p>同步标志位SYN：在TCP连接建立时用来同步序号。</p>
<h2 id="FIN"><a href="#FIN" class="headerlink" title="FIN"></a>FIN</h2><p><img src="image/image_83.png" alt="image_83"></p>
<p>终止标志位FIN：用来释放TCP连接。</p>
<h2 id="RST"><a href="#RST" class="headerlink" title="RST"></a>RST</h2><p><img src="image/image_84.png" alt="image_84"></p>
<p>复位标志位RST：用来复位TCP连接。当RST=1时，表明TCP连接出现了异常，必然释放连接，然后再重新建立连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个TCP连接。</p>
<h2 id="PSH"><a href="#PSH" class="headerlink" title="PSH"></a>PSH</h2><p><img src="image/image_85.png" alt="image_85"></p>
<p>推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付。</p>
<h2 id="URG和紧急指针"><a href="#URG和紧急指针" class="headerlink" title="URG和紧急指针"></a>URG和紧急指针</h2><p><img src="image/image_86.png" alt="image_86"></p>
<p>紧急标志位URG：取值为1时紧急指针字段有效；取值为0时紧急指针字段无效。</p>
<p>紧急指针：占16比特，以字节为单位，用来指明紧急数据的长度。</p>
<p>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急微数据，紧急数据之后是普通数据。x</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><img src="image/image_87.png" alt="image_87"></p>
<p>最大报文段长度MSS选项：TCP报文段数据载荷部分的最大长度。</p>
<p>窗口扩大选项：为了扩大窗口（提高吞吐率）。</p>
<p>时间戳选项：用来计算往返时间RTT；用来处理序号超范围的情况，又称防止序号绕回PAWS。</p>
<h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p><img src="image/image_88.png" alt="image_88"></p>
<p>填充：由于选项的长度可变，因此使用填充来确保报文段首部能被4整除（因为数据偏移字段，也就是首部长度字段，是以4字节为单位的）。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1x4411d7HU?p=57">计算机网络微课堂（有字幕有背景音乐版）_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>运输层</tag>
      </tags>
  </entry>
</search>
