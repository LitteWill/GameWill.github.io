<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Actor模型</title>
    <url>/GameWill.github.io/2021/12/25/Actor%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>Gul Agha提出了两个论点:一个Actor对象可以创建其他Actor对象；一个顺序进程无法创建其他顺序进程。<br>这两个论点并非贬低顺序程序的作用。而且也不是说，一个顺序进程无法执行其他顺序进程（数十年的主流开发经验已经证明了这一点）。但是，顺序进程仍旧是静态的，而且只能完成专门化的任务。与此相比，在高动态环境（在这种环境中可以根据需要创建和删除Actor对象，甚至可以在运行程序时，根据领域或操作环境需求更改Actor对象的行为）中，Actor 模型既可以利用顺序编程技巧，也可以利用函数编程技巧。响应式系统不仅拥有并发性和分布性，而且还拥有弹性、动态性、响应性和韧性。</p>
</blockquote>
<span id="more"></span>
<h1 id="Actor模型"><a href="#Actor模型" class="headerlink" title="Actor模型"></a>Actor模型</h1><h1 id="Actor-模型的起源"><a href="#Actor-模型的起源" class="headerlink" title="Actor 模型的起源"></a>Actor 模型的起源</h1><p>Actor 模型是一种用于处理并发计算的数学模型，它将Actor 对象用作并发计算的通用基元。与其他计算模型不同，发明Actor模型的灵感源于物理学理论，如广义相对论和量子力学。<br>可以将Actor 模型视为创建响应式应用程序的手段之一。使用这种具体的响应式软件开发方法，可以细致地处理响应式应用程序的主要方面：响应性、韧性、弹性和消息驱动性。它通过消息传递方式实现这四个方面的功能。<br>Carl Hewitt 博士是Actor 软件开发模型的发明者，他为研究该模型投入了数十年时间。Carl Hewitt 博士发现某些计算问题需要使用并发和分布模式解决，但他在做这项研究时第一台晶体管计算机仅出现了14 年，还不存在多核处理器。在1973年，功能最强大的Intel 处理器仅含有4000 至5000 个晶体管，其主频还没有超过1MHz。Carl Hewitt 博士在研究Actor 模型时，能够使用的功能最强大的处理器。处理器的硬件能力无法将Carl Hewitt 提出的理论付诸实践。因此，当时分布式和并行系统知识的理论模型与现实情况不匹配。<br><img src="image.jpg" alt="image"><br><strong><center>1973 年左右功能最强大的处理器</center></strong></p>
<h1 id="了解Actor-模型"><a href="#了解Actor-模型" class="headerlink" title="了解Actor 模型"></a>了解Actor 模型</h1><p>Actor 是一种计算实体，它会对收到的消息做出回应，并且可以做下列事情：<br>■ 向其他Actor 对象发送一定数量的消息。<br>■ 创建一定数量的新Actor 对象。<br>■ 设定对下一条消息做出的回应方式。<br>执行这些操作的次序不分先后，而且可以通过并行方式执行它们。<br>在功能齐全的Actor 系统中，所有事物都是Actor 对象。这意味着我们通常使用的基本数据类型（如字符串和整型）都是Actor对象。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTAxMTgzOC8yMDE4MTEvMTAxMTgzOC0yMDE4MTExNTE0NTQwNjYwOS0xNjEyMDM0NjU0LnBuZw"><br>Actor 是由状态（state）、行为（behavior）、邮箱（mailbox）三者组成的：</p>
<ul>
<li>状态（state）：状态是指 actor 对象的变量信息，状态由 actor 自身管理，避免并发环境下的锁和内存原子性等问题。</li>
<li>行为（behavior）：行为指定的是 actor 中计算逻辑，通过 actor 接收到的消息来改变 actor 的状态。</li>
<li>邮箱（mailbox）：邮箱是 actor 之间的通信桥梁，邮箱内部通过 FIFO 消息队列来存储发送发消息，而接收方则从邮箱中获取消息。</li>
</ul>
<p>Actor 模型描述了一组为避免并发编程的公理：</p>
<ul>
<li>所有的 Actor 状态是本地的，外部是无法访问的。</li>
<li>Actor 必须通过消息传递进行通信</li>
<li>一个 Actor 可以响应消息、退出新 Actor、改变内部状态、将消息发送到一个或多个 Actor。</li>
<li>Actor 可能会堵塞自己但 Actor 不应该堵塞自己运行的线程</li>
</ul>
<hr>
<h2 id="并发线程通信方式"><a href="#并发线程通信方式" class="headerlink" title="并发线程通信方式"></a>并发线程通信方式</h2><p>一般而言，有两种策略用来在并发线程中进行通信：<strong>共享数据</strong>和<strong>消息传递</strong> 。</p>
<h3 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a><strong>共享数据</strong></h3><p>使用<strong>共享数据</strong> 的并发编程，一般会使用各种锁去处理相关的线程安全问题；但同时也要处理各种锁所带来的问题。</p>
<p><strong>死锁</strong> ：锁的设计不当，会出现两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去的现象。</p>
<p><strong>效率低：</strong> 在高度竞争的阶段，很有可能出现很长的线程队列，他们都在等待递减计数器。但使用队列的方式的问题在于可能造成众多阻塞线程，也就是每个线程都在等待轮到它们去执行一个序列化的操作。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>实现消息传递有两种常见类型：<strong>基于channel的消息传递</strong>和<strong>基于Actor的消息传递</strong> 。</p>
<p>和共享数据方式相比，消息传递机制最大的优势在于不会产生数据竞争状态。共享内存是倾向于强一致性弱隔离性的，例如悲观锁同步的方式就是使用强一致性的方式控制并发，而 Actor 模型天然是是强隔离性且弱一致性的，所以 Actor 模型在并发中有良好的性能，而且易于控制和管理。</p>
<h1 id="Actor消息传递避免数据竞争原理"><a href="#Actor消息传递避免数据竞争原理" class="headerlink" title="Actor消息传递避免数据竞争原理"></a>Actor消息传递避免数据竞争原理</h1><p>想象我们在抢火车票，有两个线程并发地调整计数器，该计数器目前的值是 5。线程一想要将计数器的值递减 3，而线程二想要将计数器的值递减 4。它们都会检查当前计数器的值，并且会断定计数器的值大于要递减的数量。然后，它们都会继续运行并递减计数器的值。最后的结果就是 5 - 4 - 3 = -2。这样的结果会造成货品的过度分配，违反了特定的业务规则。</p>
<p>现在，我们将基于线程的实现替换为 Actor。 当然，Actor 也要在线程中运行，但是 Actor 只有在有事情可做的时候才会使用线程。在我们的计数器场景中，请求者代表了 Customer Actor。门票的数量现在由 Actor 来维护，它持有当前计数器的状态。Customer Actor 和 Tickets Actor 在空闲时（也就是没有消息要处理）都不会持有线程。</p>
<p>要初始购买操作，Customer Actor 需要发送一条 buy 消息给一个 Tickets Actor。在这样的 buy 消息中包含了要购买的数量。当 Tickets Actor 接收到 buy 消息时，它会校验购买数量不超过当前剩余的数量。如果购买请求是合法的，数量就会递减，Tickets Actor 会发送一条信息给 Customer Actor，表明订单被成功接受。如果购买数量超出了剩余数量的话，Tickets Actor 将会发送给 Customer Actor 一条消息，表明订单被拒绝了。Actor 模型本身确保处理是按照同步的方式进行的。</p>
<p>我们分三步展示 actor 之间的交互：</p>
<ol>
<li>Customer Actor 发送 buy 消息</li>
<li>Tickets Actor 处理消息</li>
<li>Tickets Actor 拒绝购买请求</li>
</ol>
<p><strong>1.Customer Actor 发送 buy 消息：</strong>  Customer Actor，它们各自发送 buy 消息给 Tickets Actor。这些 buy 消息会在 Tickets Actor 的收件箱（mailbox）中排队。发送一条消息并未将 “执行线程” 从发送者转移到目标。一个 actor 可以发送一条消息并继续无阻塞地运行。因此，在同样的时间内，它可以完成更多任务。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvNzIvNjUvNzIyODA0ZmU3MzU4N2EwNDYzMjkxMWY1NGVjYTk1NjUuanBn"></p>
<p><strong><center>Customer Actor 发送 buy 消息</center></strong> </p>
<p><strong>2.Tickets Actor 处理消息：</strong> 如下展示的是请求购买五张门票的第一条消息。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvMzUvMmYvMzUyOWUwYzAyN2QxZWU3YWUyZDc2ZGI1OTRjYzI1MmYuanBn"></p>
<p><strong><center>Tickets Actor 处理消息</center></strong> </p>
<p>当一个 Tickets  Actor 收到一条消息时，Tickets  Actor 将这条消息添加到队列尾部，如果 Tickets  Actor 没有被调度执行，它将被标记为 ready。一个调度器获取这个 Tickets  Actor 并开始执行它：Tickets  Actor 在队列头部取出一条消息。</p>
<p>随后，Tickets Actor 检查购买数量没有超出剩余门票的数量。在当前的情况下，门票数量是 15，因此购买请求能够接受，剩余门票数量会递减，Tickets Actor 还会发送一条消息给发出请求的 Customer Actor，表明门票购买成功。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvMWMvNzcvMWMyZGZiYWVjZTg0ODMxMTdjYmZjNzhmYzViZGU0NzcuanBn"></p>
<p><strong><center>Tickets Actor 处理消息队列</center></strong></p>
<p>Tickets Actor 会处理其收件箱中的每条消息。需要注意，这里没有复杂的线程或锁。这是一个<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a>的处理过程，但是 Actor 系统会管理线程的使用和分配。</p>
<p>在这里 Actor 区别于多线程并发模型的是，多线程并发模型改变了 actor 并对内部状态，而 actor 独立处理收到的消息，并且它们一个一个地响应连续到来的消息。虽然每个 actor 连续地处理发给它的消息，不同的 actors 之间并发地工作，所以一个 actor 系统可以同时处理多条消息。因为每个 actor 中同时最多处理一个消息，所以 Actor 模型无需使用锁。</p>
<p><strong>3.Tickets Actor 拒绝购买请求：</strong>  当请求的数量超过剩余值时，Tickets Actor 会如何进行处理。这里所展现的是当我们请求两张门票，但是仅剩一张门票时的情况。Tickets Actor 会拒绝这个购买请求并向发起请求的 Customer Actor 发送一条 “sold out”的消息。</p>
<p><img src="image_2.png" alt="image_2"></p>
<p><strong><center>Tickets Actor 拒绝购买请求</center></strong></p>
<p>当然，在线程方面有一定经验的开发人员会知道，可划分为两个阶段的行为检查和门票数量递减能够通过同步的操作序列来完成。以在 Java 中为例，我们可以使用同步的方法或语句来实现。但是，基于 Actor 的实现不仅在每个 Actor 中提供了自然的操作同步，而且还能避免大量的线程积压，防止这些线程等待轮到它们执行同步代码区域。在门票样例中，每个 Customer Actor 会等待响应，此时不会持有线程。这样所形成的结果就是基于 Actor 的方案更容易实现，并且会明显降低系统资源的占用。</p>
<h1 id="Actor-系统和Actor-对象基本特点"><a href="#Actor-系统和Actor-对象基本特点" class="headerlink" title="Actor 系统和Actor 对象基本特点"></a>Actor 系统和Actor 对象基本特点</h1><p><strong>■ 直接通过异步消息传递方式进行通信：</strong> 如果Actor 对象A1 要向Actor 对象A2 发送消息M1，那么Actor 对象A1 就必须知道Actor 对象A2 的地址。如果Actor 对象A1 知道Actor 对象A2的地址，那么它就能够直接向Actor 对象A2 发送消息M1，但Actor 对象A2 会使用独立线程接收和处理消息M1。换言之，消息M1 是通过异步方式被发送给Actor 对象A2 的。实际上，在发送者Actor 对象和接收者Actor 对象之间还存在一个间接处理层——邮箱（消息缓存单元）。即便如此，我们还是将这种消息传输方式称为直接传输方式，因为编程模型提供了一种宝贵的抽象，该抽象使消息就像直接从一个Actor 对象传输到另一个Actor 对象一样。</p>
<p><strong>■ 状态机：</strong> Actor 模型支持有限状态机。当Actor 对象转换为某个预设状态时，就能够改变对未来接收到的信息的处理模式。通过变为另一种消息处理器，Actor 对象就成了一种有限状态机。</p>
<p><strong>■ 无共享：</strong> 一个Actor 对象不会与其他Actor 对象或相关组件共享可变状态</p>
<p><strong>■ 无锁的并发处理方式：</strong> 因为Actor 对象不会共享它们的可变状态，而且它们在同一时刻仅会接收一条消息，所以在对消息做出回应前，Actor 对象永远都不需要尝试锁定它们的状态。因为无须使用锁策略，所以它们能够将多核CPU 从锁定问题中解放出来，集中精力提高吞吐量，并且使所有处理响应式组件的线程不被阻塞。</p>
<p><strong>■ 并行性：</strong> 并发处理方式和并行处理方式是不同的概念。并发处理方式是指多个计算操作同时出现。并行处理方式是指以并发处理方式完成单个目标。并行性是通过将单个的复杂处理过程拆分成较小的任务并以并发处理方式执行它们实现的。当等级较高的Actor 对象能够将多个任务分派给多个下级Actor 对象，或者任务中含有复杂的处理层级时，就适合通过Actor 模型使用并行处理方式。</p>
<p><strong>■ Actor 对象的系统性：</strong> 单个Actor 对象不具备并行性。Actor 对象的量级非常轻，因此在单个系统中创建许多Actor 对象是受推荐的处理方式。任何问题都可以通过添加Actor 对象来解决。</p>
<p><strong>■ 位置透明性：</strong> 使用抽象引用代表Actor 对象的地址。如果Actor 对象A1获得了Actor 对象A2 的引用，Actor 对象A1 就能够向Actor 对象A2 发送消息。提供支持的Actor 系统会负责处理传送消息的操作，不论Actor对象A2 是位于本地Actor 系统还是位于远程Actor 系统中。</p>
<p><strong>■ 监督：</strong> 在Actor 对象之间建立依赖关系，父Actor 对象监督子（下级）Actor 对象。当监督者Actor 对象向下级Actor 对象分派任务时，就必须对这些下级Actor 对象出现的失效情况做出回应。合法的回应包括继续运行、重启和停止下级Actor 对象。监督者还可以通过使本身失效从而使失效情况升级，这会将失效控制权上交给监督者的父对象（监督者的监督者）。监督机制适于在并行处理方式中使用，在该方式中监督者会将多个任务分派给多个下级对象，从而形成任务处理层级。</p>
<p>作为一种计算实体，Actor 对象与原子类似。在有可用线程的情况下，每个Actor 对象都会在收到消息时处理这条消息并且在同一时刻仅能处理一条消息，Actor 对象的性能完全由其本身的吞吐量决定，因此可以说，Actor 对象是按照自己的节奏在工作。然而，因为Actor 对象不会与其他Actor 对象共享可变状态，所以当通过计算或数据处理操作处理收到的消息时，Actor 对象也不必锁定系统资源。</p>
<p><img src="image_1.png" alt="image_1"></p>
<p><strong><center> 在有可用线程的情况下，每个Actor 对象都会在收到消息时处理这条消息 </center></strong></p>
<p><strong><center>并且在同一时刻仅能处理一条消息</center></strong></p>
<p>在无锁情况下，理论上，Actor 对象的吞吐速度会非常快。即使在某些特殊情况中，如果计算和处理操作比较小、集中和耗时较短，那么通常消息就会以极为迅速的方式被发送、接收和处理。这就使你有可能避免使用阻塞机制和导致阻塞问题的机制（串行设备）。因此，Actor 系统就能够拥有高性能、高吞吐量和低操作延迟。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《响应式架构：消息模式Actor实现与Scala、Akka应用集成》 沃恩.弗农</p>
<p><a href="https://www.infoq.cn/article/Reactive-Systems-Akka-Actors-DomainDrivenDesign">使用Akka的Actor模型和领域驱动设计构建反应式系统-InfoQ</a></p>
<p><a href="https://www.jianshu.com/p/d803e2a7de8e">Actor模型 - 简书 (jianshu.com)</a></p>
]]></content>
      <categories>
        <category>Actor模型</category>
      </categories>
      <tags>
        <tag>Actor模型</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/GameWill.github.io/2021/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>计算机网络已由一种通信基础设施发展成为一种重要的信息服务基础设施。已经像水、电、煤气这些设施一样，成为我们生活中不可或缺的一部分。</p>
</blockquote>
<span id="more"></span>

<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="image.png" alt="image"></p>
<p>因为计算机数据是突发是地出现在传输线路上，当用户正在输入和编辑一份待传输的文件时，用户所占用的通信资源暂时未被利用，该通信资源也不能被其他用户利用，宝贵的通信线路资源白白被浪费。因此计算机网络通常采用分组交换，而不是电路交换。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="image_1.png" alt="image_1"></p>
<p>假设主机H6的用户要给主机H2的用户发送一条消息，通常我们把表示该消息的整块数据称为一个报文。在发送报文之前，先把较长的报文划分称为一个个更小的等长数据段。在每一个数据段前面，加上一些有必要的控制信息组成的首部后，就构成了一个分组，也可简称为“包”，首部称为“包头”。首部中包含了分组的目的地址，否则分组传输路径中的各分组交换机（路由器），就不知道如何转发分组了。分组交换机收到一个分组后，先将分组暂时存储下来，再检查其首部，按照首部中的目的地址进行查表转发，找到合适1的转发接口，通过该接口将分组转发给下一个分组交换机。</p>
<p><img src="image_2.png" alt="image_2"></p>
<p>主机H6将所构造出的各分组依次发送出去，各分组经过途中各分组交换机的存储转发，最终到达主机H2。</p>
<p><img src="image_3.png" alt="image_3"></p>
<p>主机H2收到这些分组后，去掉它们的首部，将个数据端组合还原出原始报文。</p>
<p>分组传输过程中其中两种情况（分组丢失、误码、重复…）</p>
<ol>
<li>各分组从源站到达目的站可以走不同的路径（也就是不同的路由）；</li>
<li>分组乱序（分组到达目的站的顺序不一定与分组在源站的发送顺序相同）。</li>
</ol>
<p><img src="image_4.png" alt="image_4"></p>
<p>发送方所要完成的任务是构造分组和发送分组，路由器（分组交换机）所要完成的任务是缓存分组和转发分组（存储转发），接收方所要完成的任务是接收分组和还原报文。与分组类似，报文交换中的交换结点也采用存储转发方式。但报文交换对报文的大小没有限制，这就要求交换结点需要有较大的缓存空间。报文交换主要用于早起的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。</p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><h3 id="三种交换方式对比"><a href="#三种交换方式对比" class="headerlink" title="三种交换方式对比"></a>三种交换方式对比</h3><p><img src="image_5.png" alt="image_5"></p>
<p>假设A，B，C，D是分组传输路径上所要经过的4个结点交换机，纵坐标为时间，对于电路交换，通信之前要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送结束后，需要释放连接，以归还之前建立连接所占用的通信线路资源。</p>
<p>对于报文交换，可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</p>
<p>对于分组交换，可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各节点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</p>
<p>当使用电路交换时，一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</p>
<p>当使用报文交换时，整个报文需要在各结点交换机上进行存储转发，由于不限制报文的大小，因此需要各结点交换机都具有较大的缓存空间。</p>
<p>当使用分组交换时，构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</p>
<h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单定义：一些互相连接的、自治的计算机集合。</p>
<p>互连：指计算机之间可以通过有线或无线的方式进行数据通信；</p>
<p>自治：指独立的计算机，它有自己的硬件和软件，可以单独运行使用；</p>
<p>集合：指至少需要两台计算机</p>
<p>现阶段较好的定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某以特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p>
<p>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</p>
<p>计算机网络并非专门用来传送数据，而是能够支持很多种的应用。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="image_6.png" alt="image_6"></p>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img src="image_7.png" alt="image_7"></p>
<p><img src="image_8.png" alt="image_8"></p>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><img src="image_9.png" alt="image_9"></p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><img src="image_10.png" alt="image_10"></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p><img src="image_11.png" alt="image_11"></p>
<p><img src="image_12.png" alt="image_12"></p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p><img src="image_13.png" alt="image_13"></p>
<h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p><img src="image_14.png" alt="image_14"></p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="image_15.png" alt="image_15"></p>
<h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p><img src="image_16.png" alt="image_16"></p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="常见计算机网络体系结构"><a href="#常见计算机网络体系结构" class="headerlink" title="常见计算机网络体系结构"></a>常见计算机网络体系结构</h3><p><img src="image_17.png" alt="image_17"></p>
<p><img src="image_18.png" alt="image_18"></p>
<h3 id="分层的必要性"><a href="#分层的必要性" class="headerlink" title="分层的必要性"></a>分层的必要性</h3><p><img src="image_19.png" alt="image_19"></p>
<p><img src="image_20.png" alt="image_20"></p>
<p><img src="image_21.png" alt="image_21"></p>
<p><img src="image_22.png" alt="image_22"></p>
<p><img src="image_23.png" alt="image_23"></p>
<p><img src="image_24.png" alt="image_24"></p>
<h3 id="分层思想举例"><a href="#分层思想举例" class="headerlink" title="分层思想举例"></a>分层思想举例</h3><p><img src="image_25.png" alt="image_25"></p>
<p>应用层按HTTP协议的规定，构建一个HTTP请求报文，应用层将HTTP请求报文交付给运输层处理。</p>
<p><img src="image_26.png" alt="image_26"></p>
<p>运输层给HTTP请求报文添加一个TCP首部使之成为TCP报文段，TCP报文段的首部的作用主要是为了区分应用进程以及实现可靠传输。运输层将TCP报文段交付给网络层处理。</p>
<p><img src="image_27.png" alt="image_27"></p>
<p>网络层给TCP报文段添加一个IP首部使之成为IP数据报，IP数据报的首部的作用主要是为了使IP数据报可以再互联网上传输，即被路由器转发。网络层将IP数据报交付给数据链路层处理。</p>
<p><img src="image_28.png" alt="image_28"></p>
<p>数据链路层给IP数据报添加一个首部和一个尾部使之成为帧，以太网帧首部的作用主要是为了让帧能够在一段链路上或一个网络上传输，能够被相应的目的主机接收；以太网帧尾部的作用是为了让目的主机检查所接收到的帧是否有误码。数据链路层将帧交给物理层。</p>
<p><img src="image_29.png" alt="image_29"></p>
<p>物理层将帧看作是比特流，由于N1是以太网，因此物理层会给比特流前面添加前导码，前导码作用是为了让目的主机做好接收帧的准备。物理层将添加有前导码的比特流，变换成相应的信号发送到传输媒体，信号通过传输媒体到达路由器。</p>
<p><img src="image_30.png" alt="image_30"></p>
<p>路由器物理层将信号变换为比特流，去掉前导码后，将其交付给数据链路层。</p>
<p><img src="image_31.png" alt="image_31"></p>
<p>数据链路层将帧的首部和尾部去掉后，将其交付给网络层。</p>
<p><img src="image_32.png" alt="image_32"></p>
<p>网络层解析IP数据报的首部，从中提取出目的网络地址，然后查找自身的路由表，确定转发端口，以便进行转发，网络层将IP数据报交付给数据链路层。</p>
<p><img src="image_33.png" alt="image_33"></p>
<p>数据链路层给IP数据报添加一个首部和一个尾部使之成为帧。数据链路层将帧交付给物理层。</p>
<p><img src="image_34.png" alt="image_34"></p>
<p>物理层将帧看做是比特流，由于N2是以太网，因此物理层会给比特流前面添加前导码，物理层将添加有前导码的比特流，变换成相应的信号发送到传输媒体。信号通过传输媒体到达web服务器。</p>
<p><img src="image_35.png" alt="image_35"></p>
<p>web服务器物理层将信号变换为比特流，去掉前导码后，将其交付给数据链路层。</p>
<p><img src="image_36.png" alt="image_36"></p>
<p>数据链路层将帧的首部和尾部去掉后，将其交付给网络层。</p>
<p><img src="image_37.png" alt="image_37"></p>
<p>网络层将IP数据报的首部去掉后，将其交付给运输层。</p>
<p><img src="image_38.png" alt="image_38"></p>
<p>运输层将TCP报文段的首部去掉后，将其交付给应用层。</p>
<p><img src="image_39.png" alt="image_39"></p>
<p>应用层对HTTP请求报文进行解析，然后给主机发回HTTP响应报文。</p>
<p><img src="image_40.png" alt="image_40"></p>
<p>与之前的过程类似，HTTP响应报文需要在Web服务器层层封装，然后通过物理层换成相应的信号，再通过传输媒体传输到路由器。路由器转发该响应报文给主机。主机通过物理层将收到的信号转换成比特流。之后通过逐层解封，最终取出HTTP响应报文。</p>
<h3 id="专用术语"><a href="#专用术语" class="headerlink" title="专用术语"></a>专用术语</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p><img src="image_41.png" alt="image_41"></p>
<h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p><img src="image_42.png" alt="image_42"></p>
<p>协议三要素：语法、语义、同步</p>
<p>语法： 定义所交换信息的格式（定义了所交换信息由哪些字段以及顺序构成）</p>
<p><img src="image_43.png" alt="image_43"></p>
<p>语义：定义收发双方所要完成的操作</p>
<p>HTTP语义规定：主机要访问远程Web服务器，它会构建一个HTTP的Get请求报文，然后将其发送给Web服务器。Web服务器收到该报文并进行解析，知道这是一个HTTP的GET请求报文。于是就在自身内部查找所请求的内容， 并将所找到的内容封装在一个HTTP响应报文中发回给主机。主机收到HTTP响应报文后，对其进行解析，取出所请求的内容并由浏览器解析显示。</p>
<p>同步：定义收发双发的时序关系</p>
<p><img src="image_44.png" alt="image_44"></p>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p><img src="image_45.png" alt="image_45"></p>
<p><img src="image_46.png" alt="image_46"></p>
<p><img src="image_47.png" alt="image_47"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1x4411d7HU?p=6&spm_id_from=pageDriver">计算机网络微课堂（有字幕有背景音乐版）_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>概述</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>计算机网络概述</tag>
      </tags>
  </entry>
</search>
